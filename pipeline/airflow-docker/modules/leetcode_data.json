{
    "badges": [
        {
            "id": "6615893",
            "name": "Annual Badge",
            "shortName": "50 Days Badge 2025",
            "displayName": "50 Days Badge 2025",
            "icon": "https://assets.leetcode.com/static_assets/others/lg2550.png",
            "hoverText": "50 Days Badge 2025",
            "medal": {
                "slug": "50-days-badge-2025",
                "config": {
                    "iconGif": "https://assets.leetcode.com/static_assets/others/2550.gif",
                    "iconGifBackground": "https://assets.leetcode.com/static_assets/others/badge-background.png"
                }
            },
            "creationDate": "2025-03-23",
            "category": "ANNUAL"
        },
        {
            "id": "6313004",
            "name": "Study Plan V2 Award",
            "shortName": "LeetCode 75",
            "displayName": "LeetCode 75",
            "icon": "https://assets.leetcode.com/static_assets/others/LeetCode_75.png",
            "hoverText": "LeetCode 75",
            "medal": {
                "slug": "leetcode-75",
                "config": {
                    "iconGif": "https://assets.leetcode.com/static_assets/others/LeetCode_75.gif",
                    "iconGifBackground": "https://assets.leetcode.com/static_assets/others/badge-background.png"
                }
            },
            "creationDate": "2025-02-27",
            "category": "STUDY_PLAN"
        },
        {
            "id": "5203956",
            "name": "Study Plan V2 Award",
            "shortName": "Introduction to Pandas",
            "displayName": "Introduction to Pandas",
            "icon": "https://assets.leetcode.com/static_assets/others/Introduction_to_Pandas_Badge.png",
            "hoverText": "Introduction to Pandas",
            "medal": {
                "slug": "introduction-to-pandas",
                "config": {
                    "iconGif": "https://assets.leetcode.com/static_assets/others/Introduction_to_Pandas.gif",
                    "iconGifBackground": "https://assets.leetcode.com/static_assets/others/badge-background.png"
                }
            },
            "creationDate": "2024-10-22",
            "category": "STUDY_PLAN"
        }
    ],
    "recent_ac_submissions": [
        {
            "event_id": "1595004511",
            "event_type": "Submission",
            "problem_name": "Maximum Value of an Ordered Triplet II",
            "problem_description": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>\n\n<p>Return <em><strong>the maximum value over all triplets of indices</strong></em> <code>(i, j, k)</code> <em>such that</em> <code>i &lt; j &lt; k</code><em>. </em>If all such triplets have a negative value, return <code>0</code>.</p>\n\n<p>The <strong>value of a triplet of indices</strong> <code>(i, j, k)</code> is equal to <code>(nums[i] - nums[j]) * nums[k]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [12,6,1,2,7]\n<strong>Output:</strong> 77\n<strong>Explanation:</strong> The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.\nIt can be shown that there are no ordered triplets of indices with a value greater than 77. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,10,3,4,19]\n<strong>Output:</strong> 133\n<strong>Explanation:</strong> The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.\nIt can be shown that there are no ordered triplets of indices with a value greater than 133.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/maximum-value-of-an-ordered-triplet-ii/",
            "status": "Accepted",
            "difficulty": "Medium",
            "timestamp": "1743639373",
            "solution_url": "",
            "topics": "Array",
            "stats": "{\"totalAccepted\": \"64.4K\", \"totalSubmission\": \"123.9K\", \"totalAcceptedRaw\": 64419, \"totalSubmissionRaw\": 123868, \"acRate\": \"52.0%\"}",
            "likes": 477,
            "dislikes": 12
        },
        {
            "event_id": "1593772771",
            "event_type": "Submission",
            "problem_name": "Bitwise AND of Numbers Range",
            "problem_description": "<p>Given two integers <code>left</code> and <code>right</code> that represent the range <code>[left, right]</code>, return <em>the bitwise AND of all numbers in this range, inclusive</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 5, right = 7\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 0, right = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 1, right = 2147483647\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= left &lt;= right &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/",
            "status": "Accepted",
            "difficulty": "Medium",
            "timestamp": "1743555642",
            "solution_url": "",
            "topics": "Bit Manipulation",
            "stats": "{\"totalAccepted\": \"446.2K\", \"totalSubmission\": \"939.1K\", \"totalAcceptedRaw\": 446244, \"totalSubmissionRaw\": 939075, \"acRate\": \"47.5%\"}",
            "likes": 4122,
            "dislikes": 309
        },
        {
            "event_id": "1593752916",
            "event_type": "Submission",
            "problem_name": "Single Number II",
            "problem_description": "<p>Given an integer array <code>nums</code> where&nbsp;every element appears <strong>three times</strong> except for one, which appears <strong>exactly once</strong>. <em>Find the single element and return it</em>.</p>\n\n<p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,3,2]\n<strong>Output:</strong> 3\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0,1,0,1,0,1,99]\n<strong>Output:</strong> 99\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Each element in <code>nums</code> appears exactly <strong>three times</strong> except for one element which appears <strong>once</strong>.</li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/single-number-ii/",
            "status": "Accepted",
            "difficulty": "Medium",
            "timestamp": "1743553657",
            "solution_url": "",
            "topics": "Array, Bit Manipulation",
            "stats": "{\"totalAccepted\": \"714.1K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 714128, \"totalSubmissionRaw\": 1101552, \"acRate\": \"64.8%\"}",
            "likes": 8248,
            "dislikes": 717
        },
        {
            "event_id": "1593742822",
            "event_type": "Submission",
            "problem_name": "Maximum Value of an Ordered Triplet I",
            "problem_description": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>\n\n<p>Return <em><strong>the maximum value over all triplets of indices</strong></em> <code>(i, j, k)</code> <em>such that</em> <code>i &lt; j &lt; k</code>. If all such triplets have a negative value, return <code>0</code>.</p>\n\n<p>The <strong>value of a triplet of indices</strong> <code>(i, j, k)</code> is equal to <code>(nums[i] - nums[j]) * nums[k]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [12,6,1,2,7]\n<strong>Output:</strong> 77\n<strong>Explanation:</strong> The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.\nIt can be shown that there are no ordered triplets of indices with a value greater than 77. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,10,3,4,19]\n<strong>Output:</strong> 133\n<strong>Explanation:</strong> The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.\nIt can be shown that there are no ordered triplets of indices with a value greater than 133.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/maximum-value-of-an-ordered-triplet-i/",
            "status": "Accepted",
            "difficulty": "Easy",
            "timestamp": "1743552671",
            "solution_url": "",
            "topics": "Array",
            "stats": "{\"totalAccepted\": \"175.6K\", \"totalSubmission\": \"302.1K\", \"totalAcceptedRaw\": 175568, \"totalSubmissionRaw\": 302135, \"acRate\": \"58.1%\"}",
            "likes": 621,
            "dislikes": 36
        },
        {
            "event_id": "1592567694",
            "event_type": "Submission",
            "problem_name": "Solving Questions With Brainpower",
            "problem_description": "<p>You are given a <strong>0-indexed</strong> 2D integer array <code>questions</code> where <code>questions[i] = [points<sub>i</sub>, brainpower<sub>i</sub>]</code>.</p>\n\n<p>The array describes the questions of an exam, where you have to process the questions <strong>in order</strong> (i.e., starting from question <code>0</code>) and make a decision whether to <strong>solve</strong> or <strong>skip</strong> each question. Solving question <code>i</code> will <strong>earn</strong> you <code>points<sub>i</sub></code> points but you will be <strong>unable</strong> to solve each of the next <code>brainpower<sub>i</sub></code> questions. If you skip question <code>i</code>, you get to make the decision on the next question.</p>\n\n<ul>\n\t<li>For example, given <code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</code>:\n\n\t<ul>\n\t\t<li>If question <code>0</code> is solved, you will earn <code>3</code> points but you will be unable to solve questions <code>1</code> and <code>2</code>.</li>\n\t\t<li>If instead, question <code>0</code> is skipped and question <code>1</code> is solved, you will earn <code>4</code> points but you will be unable to solve questions <code>2</code> and <code>3</code>.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Return <em>the <strong>maximum</strong> points you can earn for the exam</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> questions = [[3,2],[4,3],[4,4],[2,5]]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The maximum points can be earned by solving questions 0 and 3.\n- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions\n- Unable to solve questions 1 and 2\n- Solve question 3: Earn 2 points\nTotal points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The maximum points can be earned by solving questions 1 and 4.\n- Skip question 0\n- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions\n- Unable to solve questions 2 and 3\n- Solve question 4: Earn 5 points\nTotal points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= questions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>questions[i].length == 2</code></li>\n\t<li><code>1 &lt;= points<sub>i</sub>, brainpower<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/solving-questions-with-brainpower/",
            "status": "Accepted",
            "difficulty": "Medium",
            "timestamp": "1743470696",
            "solution_url": "",
            "topics": "Array, Dynamic Programming",
            "stats": "{\"totalAccepted\": \"226.4K\", \"totalSubmission\": \"374.9K\", \"totalAcceptedRaw\": 226407, \"totalSubmissionRaw\": 374888, \"acRate\": \"60.4%\"}",
            "likes": 2837,
            "dislikes": 82
        },
        {
            "event_id": "1591588431",
            "event_type": "Submission",
            "problem_name": "Put Marbles in Bags",
            "problem_description": "<p>You have <code>k</code> bags. You are given a <strong>0-indexed</strong> integer array <code>weights</code> where <code>weights[i]</code> is the weight of the <code>i<sup>th</sup></code> marble. You are also given the integer <code>k.</code></p>\n\n<p>Divide the marbles into the <code>k</code> bags according to the following rules:</p>\n\n<ul>\n\t<li>No bag is empty.</li>\n\t<li>If the <code>i<sup>th</sup></code> marble and <code>j<sup>th</sup></code> marble are in a bag, then all marbles with an index between the <code>i<sup>th</sup></code> and <code>j<sup>th</sup></code> indices should also be in that same bag.</li>\n\t<li>If a bag consists of all the marbles with an index from <code>i</code> to <code>j</code> inclusively, then the cost of the bag is <code>weights[i] + weights[j]</code>.</li>\n</ul>\n\n<p>The <strong>score</strong> after distributing the marbles is the sum of the costs of all the <code>k</code> bags.</p>\n\n<p>Return <em>the <strong>difference</strong> between the <strong>maximum</strong> and <strong>minimum</strong> scores among marble distributions</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> weights = [1,3,5,1], k = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> \nThe distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6. \nThe distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10. \nThus, we return their difference 10 - 6 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> weights = [1, 3], k = 2\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The only distribution possible is [1],[3]. \nSince both the maximal and minimal score are the same, we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= weights.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= weights[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/put-marbles-in-bags/",
            "status": "Accepted",
            "difficulty": "Hard",
            "timestamp": "1743388737",
            "solution_url": "",
            "topics": "Array, Greedy, Sorting, Heap (Priority Queue)",
            "stats": "{\"totalAccepted\": \"140.6K\", \"totalSubmission\": \"193.4K\", \"totalAcceptedRaw\": 140599, \"totalSubmissionRaw\": 193407, \"acRate\": \"72.7%\"}",
            "likes": 2566,
            "dislikes": 117
        },
        {
            "event_id": "1591534361",
            "event_type": "Submission",
            "problem_name": "Intersection of Two Arrays",
            "problem_description": "<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their <span data-keyword=\"array-intersection\">intersection</span></em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]\n<strong>Output:</strong> [2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n<strong>Output:</strong> [9,4]\n<strong>Explanation:</strong> [4,9] is also accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/intersection-of-two-arrays/",
            "status": "Accepted",
            "difficulty": "Easy",
            "timestamp": "1743380736",
            "solution_url": "",
            "topics": "Array, Hash Table, Two Pointers, Binary Search, Sorting",
            "stats": "{\"totalAccepted\": \"1.5M\", \"totalSubmission\": \"1.9M\", \"totalAcceptedRaw\": 1468030, \"totalSubmissionRaw\": 1928442, \"acRate\": \"76.1%\"}",
            "likes": 6387,
            "dislikes": 2319
        },
        {
            "event_id": "1590601501",
            "event_type": "Submission",
            "problem_name": "Island Perimeter",
            "problem_description": "<p>You are given <code>row x col</code> <code>grid</code> representing a map where <code>grid[i][j] = 1</code> represents&nbsp;land and <code>grid[i][j] = 0</code> represents water.</p>\n\n<p>Grid cells are connected <strong>horizontally/vertically</strong> (not diagonally). The <code>grid</code> is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).</p>\n\n<p>The island doesn&#39;t have &quot;lakes&quot;, meaning the water inside isn&#39;t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don&#39;t exceed 100. Determine the perimeter of the island.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/island.png\" style=\"width: 221px; height: 213px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\n<strong>Output:</strong> 16\n<strong>Explanation:</strong> The perimeter is the 16 yellow stripes in the image above.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1]]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,0]]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>row == grid.length</code></li>\n\t<li><code>col == grid[i].length</code></li>\n\t<li><code>1 &lt;= row, col &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n\t<li>There is exactly one island in <code>grid</code>.</li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/island-perimeter/",
            "status": "Accepted",
            "difficulty": "Easy",
            "timestamp": "1743301483",
            "solution_url": "",
            "topics": "Array, Depth-First Search, Breadth-First Search, Matrix",
            "stats": "{\"totalAccepted\": \"711.1K\", \"totalSubmission\": \"969.5K\", \"totalAcceptedRaw\": 711133, \"totalSubmissionRaw\": 969478, \"acRate\": \"73.4%\"}",
            "likes": 7008,
            "dislikes": 403
        },
        {
            "event_id": "1590597791",
            "event_type": "Submission",
            "problem_name": "Hamming Distance",
            "problem_description": "<p>The <a href=\"https://en.wikipedia.org/wiki/Hamming_distance\" target=\"_blank\">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>\n\n<p>Given two integers <code>x</code> and <code>y</code>, return <em>the <strong>Hamming distance</strong> between them</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 1, y = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\n1   (0 0 0 1)\n4   (0 1 0 0)\n       &uarr;   &uarr;\nThe above arrows point to positions where the corresponding bits are different.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 3, y = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;=&nbsp;x, y &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as <a href=\"https://leetcode.com/problems/minimum-bit-flips-to-convert-number/description/\" target=\"_blank\"> 2220: Minimum Bit Flips to Convert Number.</a></p>\n",
            "problem_url": "https://leetcode.com/problems/hamming-distance/",
            "status": "Accepted",
            "difficulty": "Easy",
            "timestamp": "1743300995",
            "solution_url": "",
            "topics": "Bit Manipulation",
            "stats": "{\"totalAccepted\": \"621.6K\", \"totalSubmission\": \"818.8K\", \"totalAcceptedRaw\": 621583, \"totalSubmissionRaw\": 818750, \"acRate\": \"75.9%\"}",
            "likes": 3927,
            "dislikes": 224
        },
        {
            "event_id": "1589753283",
            "event_type": "Submission",
            "problem_name": "Employees Earning More Than Their Managers",
            "problem_description": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| salary      | int     |\n| managerId   | int     |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID of an employee, their name, salary, and the ID of their manager.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution&nbsp;to find the employees who earn more than their managers.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+-----------+\n| id | name  | salary | managerId |\n+----+-------+--------+-----------+\n| 1  | Joe   | 70000  | 3         |\n| 2  | Henry | 80000  | 4         |\n| 3  | Sam   | 60000  | Null      |\n| 4  | Max   | 90000  | Null      |\n+----+-------+--------+-----------+\n<strong>Output:</strong> \n+----------+\n| Employee |\n+----------+\n| Joe      |\n+----------+\n<strong>Explanation:</strong> Joe is the only employee who earns more than his manager.\n</pre>\n",
            "problem_url": "https://leetcode.com/problems/employees-earning-more-than-their-managers/",
            "status": "Accepted",
            "difficulty": "Easy",
            "timestamp": "1743228411",
            "solution_url": "",
            "topics": "Database",
            "stats": "{\"totalAccepted\": \"780K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 779951, \"totalSubmissionRaw\": 1095810, \"acRate\": \"71.2%\"}",
            "likes": 2743,
            "dislikes": 271
        },
        {
            "event_id": "1588718501",
            "event_type": "Submission",
            "problem_name": "Maximum Number of Points From Grid Queries",
            "problem_description": "<p>You are given an <code>m x n</code> integer matrix <code>grid</code> and an array <code>queries</code> of size <code>k</code>.</p>\n\n<p>Find an array <code>answer</code> of size <code>k</code> such that for each integer <code>queries[i]</code> you start in the <strong>top left</strong> cell of the matrix and repeat the following process:</p>\n\n<ul>\n\t<li>If <code>queries[i]</code> is <strong>strictly</strong> greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any <strong>adjacent</strong> cell in all <code>4</code> directions: up, down, left, and right.</li>\n\t<li>Otherwise, you do not get any points, and you end this process.</li>\n</ul>\n\n<p>After the process, <code>answer[i]</code> is the <strong>maximum</strong> number of points you can get. <strong>Note</strong> that for each query you are allowed to visit the same cell <strong>multiple</strong> times.</p>\n\n<p>Return <em>the resulting array</em> <code>answer</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2025/03/15/image1.png\" style=\"width: 571px; height: 152px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]\n<strong>Output:</strong> [5,8,1]\n<strong>Explanation:</strong> The diagrams above show which cells we visit to get points for each query.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png\" />\n<pre>\n<strong>Input:</strong> grid = [[5,2,1],[1,1,2]], queries = [3]\n<strong>Output:</strong> [0]\n<strong>Explanation:</strong> We can not get any points because the value of the top left cell is already greater than or equal to 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>k == queries.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j], queries[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/",
            "status": "Accepted",
            "difficulty": "Hard",
            "timestamp": "1743125656",
            "solution_url": "",
            "topics": "Array, Two Pointers, Breadth-First Search, Union Find, Sorting, Heap (Priority Queue), Matrix",
            "stats": "{\"totalAccepted\": \"90.9K\", \"totalSubmission\": \"152.3K\", \"totalAcceptedRaw\": 90919, \"totalSubmissionRaw\": 152316, \"acRate\": \"59.7%\"}",
            "likes": 1030,
            "dislikes": 48
        },
        {
            "event_id": "1587528358",
            "event_type": "Submission",
            "problem_name": "Minimum Index of a Valid Split",
            "problem_description": "<p>An element <code>x</code> of an integer array <code>arr</code> of length <code>m</code> is <strong>dominant</strong> if <strong>more than half</strong> the elements of <code>arr</code> have a value of <code>x</code>.</p>\n\n<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code> with one <strong>dominant</strong> element.</p>\n\n<p>You can split <code>nums</code> at an index <code>i</code> into two arrays <code>nums[0, ..., i]</code> and <code>nums[i + 1, ..., n - 1]</code>, but the split is only <strong>valid</strong> if:</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; n - 1</code></li>\n\t<li><code>nums[0, ..., i]</code>, and <code>nums[i + 1, ..., n - 1]</code> have the same dominant element.</li>\n</ul>\n\n<p>Here, <code>nums[i, ..., j]</code> denotes the subarray of <code>nums</code> starting at index <code>i</code> and ending at index <code>j</code>, both ends being inclusive. Particularly, if <code>j &lt; i</code> then <code>nums[i, ..., j]</code> denotes an empty subarray.</p>\n\n<p>Return <em>the <strong>minimum</strong> index of a <strong>valid split</strong></em>. If no valid split exists, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,2,2]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can split the array at index 2 to obtain arrays [1,2,2] and [2]. \nIn array [1,2,2], element 2 is dominant since it occurs twice in the array and 2 * 2 &gt; 3. \nIn array [2], element 2 is dominant since it occurs once in the array and 1 * 2 &gt; 1.\nBoth [1,2,2] and [2] have the same dominant element as nums, so this is a valid split. \nIt can be shown that index 2 is the minimum index of a valid split. </pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,1,3,1,1,1,7,1,2,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> We can split the array at index 4 to obtain arrays [2,1,3,1,1] and [1,7,1,2,1].\nIn array [2,1,3,1,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 &gt; 5.\nIn array [1,7,1,2,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 &gt; 5.\nBoth [2,1,3,1,1] and [1,7,1,2,1] have the same dominant element as nums, so this is a valid split.\nIt can be shown that index 4 is the minimum index of a valid split.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3,3,3,7,2,2]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> It can be shown that there is no valid split.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums</code> has exactly one dominant element.</li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/minimum-index-of-a-valid-split/",
            "status": "Accepted",
            "difficulty": "Medium",
            "timestamp": "1743035905",
            "solution_url": "",
            "topics": "Array, Hash Table, Sorting",
            "stats": "{\"totalAccepted\": \"138.4K\", \"totalSubmission\": \"182.4K\", \"totalAcceptedRaw\": 138364, \"totalSubmissionRaw\": 182362, \"acRate\": \"75.9%\"}",
            "likes": 785,
            "dislikes": 45
        },
        {
            "event_id": "1587485715",
            "event_type": "Submission",
            "problem_name": "Range Sum Query - Immutable",
            "problem_description": "<p>Given an integer array <code>nums</code>, handle multiple queries of the following type:</p>\n\n<ol>\n\t<li>Calculate the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> where <code>left &lt;= right</code>.</li>\n</ol>\n\n<p>Implement the <code>NumArray</code> class:</p>\n\n<ul>\n\t<li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>\n\t<li><code>int sumRange(int left, int right)</code> Returns the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n<strong>Output</strong>\n[null, 1, -1, -3]\n\n<strong>Explanation</strong>\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt; nums.length</code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>sumRange</code>.</li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/range-sum-query-immutable/",
            "status": "Accepted",
            "difficulty": "Easy",
            "timestamp": "1743030866",
            "solution_url": "",
            "topics": "Array, Design, Prefix Sum",
            "stats": "{\"totalAccepted\": \"679.4K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 679403, \"totalSubmissionRaw\": 1004827, \"acRate\": \"67.6%\"}",
            "likes": 3449,
            "dislikes": 1955
        },
        {
            "event_id": "1587482436",
            "event_type": "Submission",
            "problem_name": "Nim Game",
            "problem_description": "<p>You are playing the following Nim Game with your friend:</p>\n\n<ul>\n\t<li>Initially, there is a heap of stones on the table.</li>\n\t<li>You and your friend will alternate taking turns, and <strong>you go first</strong>.</li>\n\t<li>On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.</li>\n\t<li>The one who removes the last stone is the winner.</li>\n</ul>\n\n<p>Given <code>n</code>, the number of stones in the heap, return <code>true</code><em> if you can win the game assuming both you and your friend play optimally, otherwise return </em><code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> false\n<strong>Explanation:</strong> These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/nim-game/",
            "status": "Accepted",
            "difficulty": "Easy",
            "timestamp": "1743030441",
            "solution_url": "",
            "topics": "Math, Brainteaser, Game Theory",
            "stats": "{\"totalAccepted\": \"439.6K\", \"totalSubmission\": \"759.2K\", \"totalAcceptedRaw\": 439563, \"totalSubmissionRaw\": 759236, \"acRate\": \"57.9%\"}",
            "likes": 1818,
            "dislikes": 2717
        },
        {
            "event_id": "1587469285",
            "event_type": "Submission",
            "problem_name": "Ugly Number",
            "problem_description": "<p>An <strong>ugly number</strong> is a <em>positive</em> integer which does not have a prime factor other than 2, 3, and 5.</p>\n\n<p>Given an integer <code>n</code>, return <code>true</code> <em>if</em> <code>n</code> <em>is an <strong>ugly number</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 6 = 2 &times; 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 1 has no prime factors.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 14\n<strong>Output:</strong> false\n<strong>Explanation:</strong> 14 is not ugly since it includes the prime factor 7.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/ugly-number/",
            "status": "Accepted",
            "difficulty": "Easy",
            "timestamp": "1743028837",
            "solution_url": "",
            "topics": "Math",
            "stats": "{\"totalAccepted\": \"618.4K\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 618385, \"totalSubmissionRaw\": 1464219, \"acRate\": \"42.2%\"}",
            "likes": 3570,
            "dislikes": 1753
        },
        {
            "event_id": "1586273514",
            "event_type": "Submission",
            "problem_name": "Minimum Operations to Make a Uni-Value Grid",
            "problem_description": "<p>You are given a 2D integer <code>grid</code> of size <code>m x n</code> and an integer <code>x</code>. In one operation, you can <strong>add</strong> <code>x</code> to or <strong>subtract</strong> <code>x</code> from any element in the <code>grid</code>.</p>\n\n<p>A <strong>uni-value grid</strong> is a grid where all the elements of it are equal.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of operations to make the grid <strong>uni-value</strong></em>. If it is not possible, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt.png\" style=\"width: 164px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> grid = [[2,4],[6,8]], x = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> We can make every element equal to 4 by doing the following: \n- Add x to 2 once.\n- Subtract x from 6 once.\n- Subtract x from 8 twice.\nA total of 4 operations were used.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt-1.png\" style=\"width: 164px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,5],[2,3]], x = 1\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> We can make every element equal to 3.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt-2.png\" style=\"width: 164px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,2],[3,4]], x = 2\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> It is impossible to make every element equal.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= x, grid[i][j] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/",
            "status": "Accepted",
            "difficulty": "Medium",
            "timestamp": "1742948951",
            "solution_url": "",
            "topics": "Array, Math, Sorting, Matrix",
            "stats": "{\"totalAccepted\": \"135.3K\", \"totalSubmission\": \"200.6K\", \"totalAcceptedRaw\": 135318, \"totalSubmissionRaw\": 200564, \"acRate\": \"67.5%\"}",
            "likes": 1076,
            "dislikes": 72
        },
        {
            "event_id": "1586222290",
            "event_type": "Submission",
            "problem_name": "Find Right Interval",
            "problem_description": "<p>You are given an array of <code>intervals</code>, where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> and each <code>start<sub>i</sub></code> is <strong>unique</strong>.</p>\n\n<p>The <strong>right interval</strong> for an interval <code>i</code> is an interval <code>j</code> such that <code>start<sub>j</sub> &gt;= end<sub>i</sub></code> and <code>start<sub>j</sub></code> is <strong>minimized</strong>. Note that <code>i</code> may equal <code>j</code>.</p>\n\n<p>Return <em>an array of <strong>right interval</strong> indices for each interval <code>i</code></em>. If no <strong>right interval</strong> exists for interval <code>i</code>, then put <code>-1</code> at index <code>i</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2]]\n<strong>Output:</strong> [-1]\n<strong>Explanation:</strong> There is only one interval in the collection, so it outputs -1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[3,4],[2,3],[1,2]]\n<strong>Output:</strong> [-1,0,1]\n<strong>Explanation:</strong> There is no right interval for [3,4].\nThe right interval for [2,3] is [3,4] since start<sub>0</sub> = 3 is the smallest start that is &gt;= end<sub>1</sub> = 3.\nThe right interval for [1,2] is [2,3] since start<sub>1</sub> = 2 is the smallest start that is &gt;= end<sub>2</sub> = 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,4],[2,3],[3,4]]\n<strong>Output:</strong> [-1,2,-1]\n<strong>Explanation:</strong> There is no right interval for [1,4] and [3,4].\nThe right interval for [2,3] is [3,4] since start<sub>2</sub> = 3 is the smallest start that is &gt;= end<sub>1</sub> = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n\t<li>The start point of each interval is <strong>unique</strong>.</li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/find-right-interval/",
            "status": "Accepted",
            "difficulty": "Medium",
            "timestamp": "1742943888",
            "solution_url": "",
            "topics": "Array, Binary Search, Sorting",
            "stats": "{\"totalAccepted\": \"132.8K\", \"totalSubmission\": \"248.4K\", \"totalAcceptedRaw\": 132841, \"totalSubmissionRaw\": 248420, \"acRate\": \"53.5%\"}",
            "likes": 2237,
            "dislikes": 379
        },
        {
            "event_id": "1585469248",
            "event_type": "Submission",
            "problem_name": "Find First and Last Position of Element in Sorted Array",
            "problem_description": "<p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p>\n\n<p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>\n\n<p>You must&nbsp;write an algorithm with&nbsp;<code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 8\n<strong>Output:</strong> [3,4]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 6\n<strong>Output:</strong> [-1,-1]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [], target = 0\n<strong>Output:</strong> [-1,-1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums</code> is a non-decreasing array.</li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/",
            "status": "Accepted",
            "difficulty": "Medium",
            "timestamp": "1742897381",
            "solution_url": "",
            "topics": "Array, Binary Search",
            "stats": "{\"totalAccepted\": \"2.6M\", \"totalSubmission\": \"5.5M\", \"totalAcceptedRaw\": 2565200, \"totalSubmissionRaw\": 5537073, \"acRate\": \"46.3%\"}",
            "likes": 21594,
            "dislikes": 562
        },
        {
            "event_id": "1585025442",
            "event_type": "Submission",
            "problem_name": "Check if Grid can be Cut into Sections",
            "problem_description": "<p>You are given an integer <code>n</code> representing the dimensions of an <code>n x n</code><!-- notionvc: fa9fe4ed-dff8-4410-8196-346f2d430795 --> grid, with the origin at the bottom-left corner of the grid. You are also given a 2D array of coordinates <code>rectangles</code>, where <code>rectangles[i]</code> is in the form <code>[start<sub>x</sub>, start<sub>y</sub>, end<sub>x</sub>, end<sub>y</sub>]</code>, representing a rectangle on the grid. Each rectangle is defined as follows:</p>\n\n<ul>\n\t<li><code>(start<sub>x</sub>, start<sub>y</sub>)</code>: The bottom-left corner of the rectangle.</li>\n\t<li><code>(end<sub>x</sub>, end<sub>y</sub>)</code>: The top-right corner of the rectangle.</li>\n</ul>\n\n<p><strong>Note </strong>that the rectangles do not overlap. Your task is to determine if it is possible to make <strong>either two horizontal or two vertical cuts</strong> on the grid such that:</p>\n\n<ul>\n\t<li>Each of the three resulting sections formed by the cuts contains <strong>at least</strong> one rectangle.</li>\n\t<li>Every rectangle belongs to <strong>exactly</strong> one section.</li>\n</ul>\n\n<p>Return <code>true</code> if such cuts can be made; otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 5, rectangles = [[1,0,5,2],[0,2,2,4],[3,2,5,3],[0,4,4,5]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/10/23/tt1drawio.png\" style=\"width: 285px; height: 280px;\" /></p>\n\n<p>The grid is shown in the diagram. We can make horizontal cuts at <code>y = 2</code> and <code>y = 4</code>. Hence, output is true.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 4, rectangles = [[0,0,1,1],[2,0,3,4],[0,2,2,3],[3,0,4,3]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/10/23/tc2drawio.png\" style=\"width: 240px; height: 240px;\" /></p>\n\n<p>We can make vertical cuts at <code>x = 2</code> and <code>x = 3</code>. Hence, output is true.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 4, rectangles = [[0,2,2,4],[1,0,3,2],[2,2,3,4],[3,0,4,2],[3,2,4,4]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>We cannot make two horizontal or two vertical cuts that satisfy the conditions. Hence, output is false.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>3 &lt;= rectangles.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= rectangles[i][0] &lt; rectangles[i][2] &lt;= n</code></li>\n\t<li><code>0 &lt;= rectangles[i][1] &lt; rectangles[i][3] &lt;= n</code></li>\n\t<li>No two rectangles overlap.</li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/check-if-grid-can-be-cut-into-sections/",
            "status": "Accepted",
            "difficulty": "Medium",
            "timestamp": "1742867078",
            "solution_url": "",
            "topics": "Array, Sorting",
            "stats": "{\"totalAccepted\": \"106.5K\", \"totalSubmission\": \"154K\", \"totalAcceptedRaw\": 106548, \"totalSubmissionRaw\": 154020, \"acRate\": \"69.2%\"}",
            "likes": 586,
            "dislikes": 34
        },
        {
            "event_id": "1583818163",
            "event_type": "Submission",
            "problem_name": "Count Days Without Meetings",
            "problem_description": "<p>You are given a positive integer <code>days</code> representing the total number of days an employee is available for work (starting from day 1). You are also given a 2D array <code>meetings</code> of size <code>n</code> where, <code>meetings[i] = [start_i, end_i]</code> represents the starting and ending days of meeting <code>i</code> (inclusive).</p>\n\n<p>Return the count of days when the employee is available for work but no meetings are scheduled.</p>\n\n<p><strong>Note: </strong>The meetings may overlap.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">days = 10, meetings = [[5,7],[1,3],[9,10]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>There is no meeting scheduled on the 4<sup>th</sup> and 8<sup>th</sup> days.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">days = 5, meetings = [[2,4],[1,3]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>There is no meeting scheduled on the 5<sup>th </sup>day.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">days = 6, meetings = [[1,6]]</span></p>\n\n<p><strong>Output:</strong> 0</p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Meetings are scheduled for all working days.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= days &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>meetings[i].length == 2</code></li>\n\t<li><code><font face=\"monospace\">1 &lt;= meetings[i][0] &lt;= meetings[i][1] &lt;= days</font></code></li>\n</ul>\n",
            "problem_url": "https://leetcode.com/problems/count-days-without-meetings/",
            "status": "Accepted",
            "difficulty": "Medium",
            "timestamp": "1742777334",
            "solution_url": "",
            "topics": "Array, Sorting",
            "stats": "{\"totalAccepted\": \"167.3K\", \"totalSubmission\": \"350K\", \"totalAcceptedRaw\": 167338, \"totalSubmissionRaw\": 349957, \"acRate\": \"47.8%\"}",
            "likes": 721,
            "dislikes": 17
        }
    ],
    "recent_solutions": [
        {
            "event_id": 6601600,
            "event_type": "Solution",
            "problem_name": "Solving Questions With Brainpower",
            "problem_description": "",
            "problem_url": "https://leetcode.com/problems/solving-questions-with-brainpower/description/",
            "difficulty": "",
            "timestamp": "2025-04-01T01:26:04.217897+00:00",
            "solution_name": "C++ / Python - Dynamic Programming",
            "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nCreate a dynamic programming array to store the best possible score starting at each index. Start at the end of the test initially and work backwards since the best score for a student starting at the last question is simply to do the only available question. Iteratve backwards and calculate whether the current question should be completed or not. This is possible since all questions following the currently inspected question already have their best possible score calculated. \n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nInitialise a dynamic programming array `vector<long long> dp(q, 0)` where `q = questions.size()`. Set the last value in this array to equal the points attainable by completing the final question on the test `dp[q-1] = questions[q-1][0]`. Now, iteratre backwards from the second to last\n\n1. Initialise a dynamic programming array `vector<long long> dp(q, 0)` where `q = questions.size()`.\n2. Set the last value in this array to equal the points attainable by completing the final question on the test `dp[q-1] = questions[q-1][0]`.\n3. Now, iteratre backwards from the second to last question to the first question. Achieve this with the loop `for (int i=q-2; i>=0; i--)`.\n4. For each value of `i`, set variables `int points = questions[i][0]` and `int brainpower = questions[i][1]` as the points and brainpower values for the current i-th question.\n5. Check whether the condition `i + brainpower + 1 < q` is true. This tests whether, if the question is completed, there is another question able to be completed before the test is finished (need this check to not access beyond bounds of question).\n6. If above condition is true then set `dp[i] = max(dp[i+1], points + dp[i + brainpower + 1])`. This reads as the better option of skipping this question and taking the best score starting from question `i + 1` or completing this question and adding the best possible score of the next available question.\n7. If above condition is false, then no other questions can be completed if the current question is completed. As such, the best score at this question will be the `dp[i] = max(points, dp[i+1])`.\n8. Return the best possible score starting from the beginning of the test `dp[0]`\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is the number of questions\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is the number of questions\n\n# Code\n```cpp []\nclass Solution {\npublic:\n    long long mostPoints(vector<vector<int>>& questions) {\n        int q = questions.size();\n        vector<long long> dp(q, 0);\n        dp[q-1] = questions[q-1][0];\n        for (int i = q-2; i >= 0; i--){\n            int points = questions[i][0];\n            int brainpower = questions[i][1];\n            if (i + brainpower + 1 < q){\n                dp[i] = max(dp[i+1], points + dp[i + brainpower + 1]);\n            } else {\n                dp[i] = max(static_cast<long long>(points), dp[i+1]);\n            }\n        }\n        return dp[0];\n    }\n};\n```\n``` python3 []\nclass Solution:\n    def mostPoints(self, questions: List[List[int]]) -> int:\n        q = len(questions)\n        dp = [0] * q\n        dp[-1] = questions[-1][0]\n        for i in range(q - 2, -1, -1):\n            points, brainpower = questions[i]\n            if i + brainpower + 1 < q:\n                dp[i] = max(dp[i+1], points + dp[i+brainpower+1])\n            else:\n                dp[i] = max(points, dp[i+1])\n\n        return dp[0]\n```",
            "solution_url": "https://leetcode.com/problems/solving-questions-with-brainpower/6601600/c-python-dynamic-programming-by-jo3-h-kk5m",
            "topics": "Array, Dynamic Programming, C++, Python3",
            "hits": 2,
            "likes": 0,
            "dislikes": 0
        },
        {
            "event_id": 6587967,
            "event_type": "Solution",
            "problem_name": "Maximum Number of Points From Grid Queries",
            "problem_description": "",
            "problem_url": "https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/description/",
            "difficulty": "",
            "timestamp": "2025-03-28T01:57:10.735408+00:00",
            "solution_name": "C++ - BFS / Priority Queue",
            "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is to simply search using BFS to solve for each query. Not difficult to implement. However, this is not an optimal approach. The key point to understand in this context is that the initial position is the same for all queries. Once this has been accepted, consider all potential values of `queries[i]`. Since the question states that for a node in the grid to be accessable, the value of `queries[i]` must be strictly larger than the node value, it is true that for any queries `x` and `y` such that `x < y`, the BFS explored nodes for `x` will be a sub-set nodes explored for `y`. \n\nThis condition can be extended. If `queries` is sorted in ascending order, for all elements in `queries` nodes explored in BFS for `queries[i]` will be a sub-set of nodes explored in `queries[i+1]`.\n\nOnce this is realised, a single BFS pass can be constructed for the largest value of `queries[i]`, making sure to explore the smallest valued nodes first. For each value of `queries[i]` once there are no more nodes that have been found that satisfy the condition `queries[i] > grid[x][y]`, push the current answer to the result and contniue the search with the larger value of `queries[i]`.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nFirst, initialise `int m, n` to store the dimensions of the grid. `vector<int> ans` will be used to store the resulting vector. Now, utilise a `vector<pair<int, int>> sortedQueries` to store sorted queries which maintaining references to their original index in `queries`. Sort this by first element. Initialise a priority queue `priority_queue<pair<int, pair<int, int>>> pq` which holds a given node's value along with its position in the martix. Also a boolean matrix the same size as the grid indicating whether a node has been seen yet. Set the inital position (0, 0) to TRUE. Push the starting position to the queue along with its value. \n\nNow, intialise a variable `int currentAns = 0` to store the number of points currently earned. \n\nIterate through each query and while the queue is not empty and the smallest value of a reached node is smaller than the current query, explore the node at the front of the queue. Pop this node from the front of the queue and check the validity of neighbours by checking for out of bounds and whether neighbour has been seen or not. If vaild neighbour then push to queue and set seen as True.\n\nOnce there are no more nodes in the queue that this query can earn points for, set the answer for this query to the current value of `currentAns`. Since the value of query is increasing with each iteration, the currentAns can be carried over to the next query, thus, continue BFS until all queries have been processed and the queue is empty. \n\nReturn the Ans vector.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O(n*m log (n*m))$$\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(m*n)$$\n\n# Code\n```cpp []\nclass Solution {\n\npublic:\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\n        int m = grid.size();\n        int n = grid[0].size();\n        vector<int> ans(queries.size(), 0);\n\n        vector<pair<int, int>> sortedQueries;\n        for (int i=0; i<queries.size(); i++){\n            sortedQueries.push_back({queries[i], i});\n        }\n        sort(sortedQueries.begin(), sortedQueries.end());\n\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;\n        pq.push({grid[0][0], {0,0}});\n\n        vector<vector<bool>> seen(m, vector<bool>(n, false));\n        vector<int> dx = {-1, 1, 0, 0};\n        vector<int> dy = {0, 0, 1, -1};\n        seen[0][0] = true;\n\n        // iterate through each query and explore the reachable nodes that are below the current query value\n        int currentAns = 0;\n        for (auto &[query, index] : sortedQueries){\n\n            while (!pq.empty() && pq.top().first < query){\n\n                auto [value, pos] = pq.top();\n                pq.pop();\n                currentAns++;\n\n                for (int i=0; i<4; i++){\n                    int ny = pos.second + dy[i];\n                    int nx = pos.first + dx[i];\n\n                    if (ny < 0 || ny >= n || nx < 0 || nx >= m || seen[nx][ny]){\n                        continue;\n                    }\n                    seen[nx][ny] = true;\n                    pq.push({grid[nx][ny],{nx, ny}});\n                }\n\n            }\n\n            ans[index] = currentAns;\n\n        }\n\n        return ans;\n    }\n};\n```",
            "solution_url": "https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/6587967/c-bfs-priority-queue-by-jo3-h-xcbb",
            "topics": "Breadth-First Search, Heap (Priority Queue), C++",
            "hits": 16,
            "likes": 0,
            "dislikes": 0
        },
        {
            "event_id": 6583957,
            "event_type": "Solution",
            "problem_name": "Minimum Index of a Valid Split",
            "problem_description": "",
            "problem_url": "https://leetcode.com/problems/minimum-index-of-a-valid-split/description/",
            "difficulty": "",
            "timestamp": "2025-03-27T00:57:16.996466+00:00",
            "solution_name": "C++ - Precompute dominantCount subarray",
            "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is to check all candidate values of `i` which could potentially lead to a valid split. Return the first one found since `i` is enumerated upwards. If no valid `i` is found, return `-1`.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nAbstract the functionality for computing the `dominantElement` and precomputing the count of this element at each index to functions `getDominant(vector<int>)` and `precomputeDominantCount(vector<int>, int)` respectively.\n\n-`getDominant(vector<int>& nums)`\nThis function works by harnessing an unordered_map `unordered_map<int, int> freq` which will function as a freqency map storing each element and its count of occurances in input num. Also, initialise `int maxFreq = 0` and `int maxElement = nums[0]` to store the best found element and frequency. Iterate elements of nums and enumerate the value of `freq[num]` and check whether this has become the most frequent element. Upon finding the most frequent element, check whether it is more than half of the elements in the array. If so, return `maxElement` else return `-1`.\n\n-`precomputeDominantCount(vector<int>& nums, int dominant)`\nThis function works by initialising a vector<int> `ans` which matches the size of nums and stores an array of 0s. Iterate through nums and for each element in index `i`, if condition `nums[i] == dominant` evaluates to `true` then the count of dominant to index `i` is `ans[i] = ans[i-1] + 1` else `ans[i] = ans[i-1]`.\n\nOnce these have been set up, move to checking for valid candidate `i` values. Iterate `i` and calculate the number of occurances of `dominant` in the left subarray by setting `leftCount = dominantCount[i]` and the right subarray by setting `rightCount = dominantEnd - dominantCount[i]`. If these two values are larger than half of the size of each subarray respectively, then return `i`. If no valid value is found, return `-1`. \n\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is size of input array\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is size of input array\n\n# Code\n```cpp []\nclass Solution {\nprivate:\n    vector<int> precomputeDominantCount(vector<int>& nums, int dominant){\n        vector<int> ans(nums.size(), 0);\n        if (nums[0] == dominant){ ans[0] = 1; }\n        for (int i=1; i<nums.size(); i++){\n            if (nums[i] == dominant){\n                ans[i] = ans[i-1] + 1;\n            } else {\n                ans[i] = ans[i-1];\n            }\n        }\n        return ans;\n    }\n\n    int getDominant(vector<int>& nums){\n        unordered_map<int, int> freq;;\n        int maxFreq = 0; \n        int maxElement = nums[0];\n\n        for (int num : nums){\n            freq[num]++;\n            if (freq[num] > maxFreq){\n                maxFreq = freq[num];\n                maxElement = num;\n            }\n        }\n\n        return (freq[maxElement] * 2 > nums.size()) ? maxElement : -1;;\n    }\n\npublic:\n    int minimumIndex(vector<int>& nums) {\n        \n        int dominant = getDominant(nums);\n        if (dominant == -1){ return -1; }\n        vector<int> dominantCount = precomputeDominantCount(nums, dominant);\n        int dominantEnd = dominantCount[nums.size()-1];\n\n        for (int i = 0; i < nums.size() - 1; i++) {\n            int leftCount = dominantCount[i];\n            int rightCount = dominantEnd - dominantCount[i];\n\n            if (leftCount * 2 > (i + 1) && rightCount * 2 > (nums.size() - i - 1)) {\n                return i;\n            }\n        }\n        \n        return -1;\n\n    }\n};\n```",
            "solution_url": "https://leetcode.com/problems/minimum-index-of-a-valid-split/6583957/c-precompute-dominantcount-subarray-by-j-sfyh",
            "topics": "Array, Hash Table, C++",
            "hits": 5,
            "likes": 0,
            "dislikes": 0
        },
        {
            "event_id": 6553340,
            "event_type": "Solution",
            "problem_name": "Minimum Operations to Make Binary Array Elements Equal to One I",
            "problem_description": "",
            "problem_url": "https://leetcode.com/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/description/",
            "difficulty": "",
            "timestamp": "2025-03-19T01:11:08.873779+00:00",
            "solution_name": "C++ / Python - Bit Manipulation ",
            "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition here is to inspect each element and check whether it needs to be flipped, if it does then make the operation on the bit and the following 2 bits before checking whether the right subarray is able to be turned into 1. This is a divide and conquer approach.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nStore a variable `ans = 0` to hold the count of operations performed. Store variable `n = nums.size()` as the size of the input array. Now, utilise a for loop to iterate through all elements of nums. At each element inspect for condition `nums[i] == 0` to be true. If this is true then the bit must be flipped. Therefore, enumerate `ans++` and set the next two elements to their inverse digit using bit manipulation `nums[i+1] ^= 1`. Note that if this condition is found to be true for either of the last 2 elements in the array then return early -1 since this implies array cannot be turned into 1s. \n\nUpon completion of for loop. Simply return the count of operations stored in `ans` variable.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is size of input array nums\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(1)$$ Since constant number of varaibles used to hold count of ans.\n\n# Code\n```cpp []\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n        int ans = 0;\n        int n = nums.size();\n        for (int i=0; i<n; i++){\n            if (nums[i] == 0){\n                if (i > n - 3){ return -1; }\n                nums[i+1] ^= 1;\n                nums[i+2] ^= 1;\n                ans++;\n            }\n        }\n\n        return ans;\n    }\n};\n```\n``` python3 []\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        for i, num in enumerate(nums):\n            if (num == 0):\n                if i > len(nums) - 3:\n                    return -1\n\n                nums[i + 1] ^= 1\n                nums[i + 2] ^= 1\n                ans += 1\n        \n        return ans\n```",
            "solution_url": "https://leetcode.com/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/6553340/c-python-bit-manipulation-by-jo3-h-9ov1",
            "topics": "Array, Bit Manipulation, C++, Python3",
            "hits": 2,
            "likes": 0,
            "dislikes": 0
        },
        {
            "event_id": 6549443,
            "event_type": "Solution",
            "problem_name": "Longest Nice Subarray",
            "problem_description": "",
            "problem_url": "https://leetcode.com/problems/longest-nice-subarray/description/",
            "difficulty": "",
            "timestamp": "2025-03-18T00:58:40.322796+00:00",
            "solution_name": "C++ / Python3 - Sliding Window",
            "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is to use sliding window technique to search for subarrays which abide by the given condition. Iteratively expand the window by enumerating the right boundary of index and shrink the window until the condition in the description is satisfied. Update the answer variable to be max of current value and current window size. \n\n# Approach\n<!-- Describe your approach to solving the problem. -->\ninitialise three variables:\n1. `window = 0` to store the bitwise OR of all elements in current window\n2. `left = 0` to store the left index of the current window\n3. `ans = 0` to store the current largest valid window size\n\nNow, iterate values of `right` from 0 to nums.size() - 1 to investigate all potential right bounds of sliding window. For each incremental value of `right`, check whether the element `nums[right]` can be added to the window without breaking the conditions. This can be done by checking the  condition: `(window & nums[right]) != 0`. Since window holds a 1 in each position in which a bit is already present in the window, if the bitwise AND of this value and the candidate (nums[right]) that is attempting to be added is not zero then this implies that there is multiple 1s in one position. While this condition is true, reduce the window size by enumerating `left` and remove the leftmost element from the window by applying `window ^= nums[left]`.\n\nOnce the above has been done, the current window will be the largest possible given the current value of `right`. At this point we apply the OR operation to window to add `nums[right]` to the window; `window |= nums[right]`. Update the value of ans: `ans = max(ans, right - left + 1)`.\n\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O( n )$$ where n is the length of nums\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(1)$$\n\n# Code\n```cpp []\nclass Solution {\npublic:\n    int longestNiceSubarray(vector<int>& nums) {\n        int window = 0;\n        int left = 0;\n        int ans = 0;\n        for (int right=0; right<nums.size(); right++){ // iterate potential values for right boundary of window\n\n            while ((window & nums[right]) != 0){ // check whether right element can be added without contradiction\n                window ^= nums[left];\n                left++;\n            }\n\n            window |= nums[right]; // add nums[right] to window\n            ans = max(ans, right - left + 1); // update max window size\n\n        }\n\n        return ans;\n\n    }\n};\n```\n``` python3 []\nclass Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        window = 0\n        left = 0\n        ans = 0\n\n        for right in range(0, len(nums)):\n\n            while (window & nums[right]) != 0:\n                window ^= nums[left]\n                left += 1\n\n            window |= nums[right]\n            ans = max(ans, right - left + 1)\n\n        return ans\n```",
            "solution_url": "https://leetcode.com/problems/longest-nice-subarray/6549443/c-python3-sliding-window-by-jo3-h-jv1g",
            "topics": "Bit Manipulation, Sliding Window, C++, Python3",
            "hits": 9,
            "likes": 0,
            "dislikes": 0
        },
        {
            "event_id": 6544797,
            "event_type": "Solution",
            "problem_name": "Divide Array Into Equal Pairs",
            "problem_description": "",
            "problem_url": "https://leetcode.com/problems/divide-array-into-equal-pairs/description/",
            "difficulty": "",
            "timestamp": "2025-03-17T00:22:14.687033+00:00",
            "solution_name": "C++ / Python - Frequency Map",
            "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is to recognise that the actual pairs of elements do not have to be returned. Simply a boolean return type indicating whether this is possible. As such, we can use a frequency map to determine whether there is an even number of each unique number in nums. \n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nInitialise `unordered_map<int, int> freq_map` to store the frequency of each element. Iterate through `nums` and enumerate each value `freq_map[num]++ for num in nums`. Once this frequency map is build, iterate through items in map and check value for condition `value % 2 == 1`. If this value is true at any point, return false since this implies that there is a number that will not have a matching element to make a pair. Once all key - value pairs are checked for contradicion, if none has been found, return true.\n\nNote that key is not used in checking for contradiction since the actual value is not important, only its frequency.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is number of elements in nums\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ since average case will be n/2 unique numbers\n\n# Code\n``` cpp []\nclass Solution {\npublic:\n    bool divideArray(vector<int>& nums) {\n\n        // Initialse frequency map\n        unordered_map<int, int> freq_map;\n\n        // Count each occurrance of element in nums\n        for (int& n : nums){\n            freq_map[n]++;\n        }\n\n        // check for odd number of any element (proof by contradiction)\n        for (auto& [_, value] : freq_map){\n            if (value % 2 == 1){ return false; }\n        }\n\n        // else return true\n        return true;\n    }\n};\n```\n```python3 []\nclass Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        \n        # initialise frequency map\n        freq_map = {}\n\n        # count occurrances of elements\n        for num in nums:\n            if num not in freq_map:\n                freq_map[num] = 0\n            freq_map[num] += 1\n        \n        # check for odd count of element\n        for _, value in freq_map.items():\n            if value % 2 == 1:\n                return False\n        \n        # else return true\n        return True\n```\n",
            "solution_url": "https://leetcode.com/problems/divide-array-into-equal-pairs/6544797/c-python-frequency-map-by-jo3-h-4qrr",
            "topics": "Array, Hash Table, Counting, C++, Python3",
            "hits": 1,
            "likes": 0,
            "dislikes": 0
        },
        {
            "event_id": 6541070,
            "event_type": "Solution",
            "problem_name": "Minimum Time to Repair Cars",
            "problem_description": "",
            "problem_url": "https://leetcode.com/problems/minimum-time-to-repair-cars/description/",
            "difficulty": "",
            "timestamp": "2025-03-16T02:07:50.478683+00:00",
            "solution_name": "C++ / Python - Binary Search",
            "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nInituition is to search for a time that would be able to successfully repair all the cars while also being a minimum. First thought would be to use priority queues to determine time next car can be worked on and finished, this would be optimal if the time a mechanic take to copmlete a car is exponentially related to the number of cars he services. Because of this, we must use Binary Search.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nDefine two boundary values inbetween which much lie the optimal time. Set `left = 0` since the best case scenario is that there are zero cars to repair and it will take zero time to complete. Set `right = max(ranks * cars * cars)` since in the worst case scenario the worst mechanic will work on all of the cars, this is the upper bound for time. Note that this is assuming that mechanics can begin working on the next car in zero time. \n\nNow, definie the middle of the upper and lower bounds for our solution as `candidateTime = left + (right - left) / 2`. This serves as the midpoint and our candidate value for time. Check whether this candidate time is valid by passing to a member method. If this value is valid then set `ans = candidateTime` and move the upper bound to search for smaller candidate times `right = candidateTime - 1`. Otherwise, if the candidate time value is not valid, move the lower bound to search for larger candidate times `left = candidateTime + 1`. Repeat this until the search has set the upper and lower bounds such that `left > right`. \n\nTo check whether a given candidate time is valid, simply iterate through ranks and calculate the max number of cars a given mechanic can repair given the time. This can be calculated by using algebraic  principles on the formula for time. i.e. given candidateTime: `carsRepaired = floor(square_root(candidateTime / rank_of_mechanic))`. Keep a sum total of the number of `carsRepaired` and if the condition `carsRepaird >= cars` return True, else return False.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO(n log m) where n is ranks.size() and m is max(ranks) * cars * cars\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(1) due to constant number of variables used throughout search and validation.\n\n# Code\n``` cpp []\nclass Solution {\nprivate:\n    bool validTime(vector<int>& ranks, long long candidateTime, int cars){\n\n        long long carsRepaired = 0;\n        for (int rank : ranks){\n            carsRepaired += static_cast<long long>(sqrt(candidateTime / rank));\n            if (carsRepaired >= cars){ return true; }\n        }\n\n        return (carsRepaired >= cars);\n    }\n\npublic:\n    long long repairCars(vector<int>& ranks, int cars) {\n        long long left = 0;\n        long long right = static_cast<long long>(ranks.back()) * cars * cars;\n        long long ans = 0;\n        while (left <= right){\n            long long candidateTime = left + (right - left) / 2;\n            if (validTime(ranks, candidateTime, cars)){\n                right = candidateTime - 1;\n                ans = candidateTime;\n            } else {\n                left = candidateTime + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n```\n```python3 []\nclass Solution:\n    def validTime(self, ranks: List[int], candidateTime: int, cars: int) -> bool:\n        carsRepaired = 0\n        for rank in ranks:\n            carsRepaired += math.floor(math.sqrt(candidateTime/rank))\n            if carsRepaired >= cars:\n                return True\n        \n        return carsRepaired >= cars\n\n    def repairCars(self, ranks: List[int], cars: int) -> int:\n        left = 0\n        right = max(ranks) * cars * cars\n        ans = 0\n        while (left <= right):\n            candidateTime = left + (right - left) // 2\n            if (self.validTime(ranks, candidateTime, cars)):\n                ans = candidateTime\n                right = candidateTime - 1\n            else:\n                left = candidateTime + 1\n        \n        return ans\n```",
            "solution_url": "https://leetcode.com/problems/minimum-time-to-repair-cars/6541070/c-python-binary-search-by-jo3-h-hzk9",
            "topics": "C++, Python3",
            "hits": 6,
            "likes": 0,
            "dislikes": 0
        },
        {
            "event_id": 6537488,
            "event_type": "Solution",
            "problem_name": "House Robber IV",
            "problem_description": "",
            "problem_url": "https://leetcode.com/problems/house-robber-iv/description/",
            "difficulty": "",
            "timestamp": "2025-03-15T01:11:03.489894+00:00",
            "solution_name": "C++ / Python - Binary Search",
            "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nInituition is to select candidate values of capability and check for validity. Depending on whether this capability is valid with the provided valud of `k`, move the binary search to a new value.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nInitialise two variables `minElement = 1` and `maxElement = max(nums[i] for i in nums)` as the upper and lower potential value for answer.\n\nCalculate the midpoint of these two boundary values as `midElement = minElement + (maxElement - minElement) / 2`. Use this value to check whether it satisfies the conditions of the problem. If it does then set `ans = midElement` and change bounds to search for a smaller value by setting `minElement = midElement - 1`. Otherwise, search larger elements by setting `maxElement = midElement + 1`.  Continue until `maxElement > minElement`. At this point we will have the best candidate result stored in `ans`.\n\nTo work out the validity of a candidate, define function `validK()` which iterates through values in `nums` and dynamically calculates the number of houses that can be robbed at this candidate value. Return the bool returned when comparing the found values to k. If equal or larger than k, return `True` otherwise, return `False`.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO(n log n) where n is the size of input array nums; \n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(1) since constant number of variables are used.\n\n# Code\n```cpp []\nclass Solution {\nprivate:\n    bool validK(vector<int>& nums, int candidate, int k){\n        int i=0;\n        int ans=0;\n        while (i<nums.size()){\n            if (nums[i]<=candidate){\n                ans++;\n                i += 2;\n            } else {\n                i++;\n            }\n        }\n        return (ans >= k);\n    }\n\npublic:\n    int minCapability(vector<int>& nums, int k) {\n        if (k == 0){return 0;}\n        int maxElement = *max_element(nums.begin(), nums.end());\n        int minElement = 1;\n        int ans = -1;\n        \n        while (minElement <= maxElement){\n            int midElement = minElement + (maxElement - minElement) / 2;\n            if (validK(nums, midElement, k)){\n                maxElement = midElement - 1;\n                ans = midElement;\n            } else {\n                minElement = midElement + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n```\n``` python3 []\nclass Solution:\n    def validK(self, nums, candidate, k):\n        i = 0\n        ans = 0\n        while i < len(nums):\n            if (nums[i] <= candidate):\n                ans += 1\n                i += 2\n            else:\n                i += 1\n        return ans >= k\n\n    def minCapability(self, nums: List[int], k: int) -> int:\n\n        if k == 0:\n            return 0\n\n        maxElement = max(nums)\n        minElement = min(nums)\n        ans = -1\n\n        while minElement <= maxElement:\n            midElement = (minElement + maxElement) // 2\n            if (self.validK(nums, midElement, k)):\n                ans = midElement\n                maxElement = midElement - 1\n\n            else:\n                minElement = midElement + 1\n\n        return ans\n```",
            "solution_url": "https://leetcode.com/problems/house-robber-iv/6537488/c-python-binary-search-by-jo3-h-93oa",
            "topics": "C++",
            "hits": 3,
            "likes": 0,
            "dislikes": 0
        },
        {
            "event_id": 6534161,
            "event_type": "Solution",
            "problem_name": "Maximum Candies Allocated to K Children",
            "problem_description": "",
            "problem_url": "https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/",
            "difficulty": "",
            "timestamp": "2025-03-14T01:08:10.011174+00:00",
            "solution_name": "C++ / Python - Binary Search",
            "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nThe maximum value of candies that can be assigned to any child is the size of the largest pile since each child can only be assigned one pile. The smallest value is the default case of 0 if there is more children than candies. Knowing this range of return values, binary search method can be used to identify which is the largest valid value for candies per child.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nDefine variable `ans` to hold the largest valid value for candies per child seen thus far. Initialise this variable `ans = 0` since if no valid values are found, zero will be returned. \n\nInitialise `left = 1` to hold the left boundary of the search values (can ignore 0 since initialised ans to zero), and `right = max(candies)` as the max value ans could take. Binary search by initialising `int candidate = left + (right - left) / 2`, this is effectively the mid-point between the search bounds left / right. Check this candidate value for ability to distribute to `k` children (see below for method). If this value is valid then update `ans = candidate` and move the left bound to check larger, unchecked, values `left = candidate + 1`. If the candidate value is invalid then move right bound to check smaller candidate values for validity `right = candidate - 1`. Repeat this process while `left <= right`. Once this loop is completed, best found result is stored in `ans` and can be returned.\n\nTo calculate whether a candidate value `candidate` is valid, abstract to a function `validCandies()`. This function counts the potential children that can be assigned this number of candies. Initialise a variable `childrenCount` to count the children that can receive this number of candies. Iterate each pile `candies[i]` and add to the count the max number of sub-piles of size `candidates` that can be made from this pile: `childrenCount += candies[i] / candidates`. Return true if `childrenCount >= k` indicating a valid candidate value.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO(m * log n) where n is `max(candies[i])` and m is size of `candies`\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(n) where n is the size of the input array `candides`\n\n\n# Code\n```cpp []\nclass Solution {\nprivate:\n    bool validCandies(int candidate, vector<int>& candies, long long k){\n        long long countChildren = 0;\n        for (auto& pile : candies){\n            countChildren += pile / candidate;\n            if (countChildren >= k) return true;\n        }\n        return (countChildren >= k);\n    }\n\npublic:\n    int maximumCandies(vector<int>& candies, long long k) {\n\n        // initialise variables\n        int ans = 0;\n        int left = 1;\n        int right = *max_element(candies.begin(), candies.end());\n\n        // binary search values for valid candies per child (ans), store the most recently found\n        while (left <= right){\n            int candidate = left + (right - left)/2;\n            if (validCandies(candidate, candies, k)){\n                ans = candidate;\n                left = candidate + 1;\n            } else {\n                right = candidate - 1;\n            }\n        }\n\n        return ans;\n    }\n};\n```\n``` python3 []\nclass Solution:\n    def validCandies(self, candidate: int, candies: List[int], k: int):\n        childrenCount = 0\n        for pile in candies:\n            childrenCount += pile // candidate\n            if childrenCount >= k:\n                return True\n\n        return childrenCount >= k\n\n    def maximumCandies(self, candies: List[int], k: int) -> int:\n        ans = 0\n        left = 1\n        right = max(candies)\n        while left <= right:\n            candidate = left + ((right - left) // 2)\n            if (self.validCandies(candidate, candies, k)):\n                ans = candidate\n                left = candidate + 1\n            else:\n                right = candidate - 1\n\n        return ans\n```",
            "solution_url": "https://leetcode.com/problems/maximum-candies-allocated-to-k-children/6534161/c-python-binary-search-by-jo3-h-wg4d",
            "topics": "C++, Python3",
            "hits": 3,
            "likes": 0,
            "dislikes": 0
        },
        {
            "event_id": 6531899,
            "event_type": "Solution",
            "problem_name": "First Bad Version",
            "problem_description": "",
            "problem_url": "https://leetcode.com/problems/first-bad-version/description/",
            "difficulty": "",
            "timestamp": "2025-03-13T08:43:48.850464+00:00",
            "solution_name": "C++ / Python - Binary Search",
            "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition here is exactly the same as a binary search for a number that is in an array, however, in this case the condition we are looking for is not an equality of number at some index to a target number, the condition is a true result from the `isBadVersion()` API.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nset a variable `left` to 1 (the minimum version number) and `right` to the input to the function `n`. Also initialise an int `ans` which will store the best answer to the current iteration of the loop. While left is less than or equal to right we can find the midpoint number `mid` and check whether this version is bad. If version is bad then update `ans = mid` and move `right = mid - 1`, if the version is good then move `left = mid + 1`. Once the loop is exited, then the smallest version number which is bad will be stored in `ans`. Return this value.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO(log n) where n is the input to the `firstBadVersion()` function\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(1) since only three ints are required to find solution\n\n# Code\n```cpp []\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int right) {\n        int left = 1;\n        int ans;\n        while (left <= right){\n            long long mid = left + (right - left)/2;\n            if (!isBadVersion(mid)){\n                left = mid + 1;\n            } else {\n                ans = mid;\n                right = mid - 1;\n            }\n        }\n        return ans;\n    }\n};\n```\n```python3 []\n# The isBadVersion API is already defined for you.\n# def isBadVersion(version: int) -> bool:\n\nclass Solution:\n    def firstBadVersion(self, right: int) -> int:\n        left = 1\n        ans = 0\n        while (left <= right):\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return ans\n```",
            "solution_url": "https://leetcode.com/problems/first-bad-version/6531899/c-python-binary-search-by-jo3-h-wnsf",
            "topics": "C++",
            "hits": 1,
            "likes": 0,
            "dislikes": 0
        },
        {
            "event_id": 6531830,
            "event_type": "Solution",
            "problem_name": "Merge Two Binary Trees",
            "problem_description": "",
            "problem_url": "https://leetcode.com/problems/merge-two-binary-trees/description/",
            "difficulty": "",
            "timestamp": "2025-03-13T08:05:25.450193+00:00",
            "solution_name": "C++ / Python - Recursion ",
            "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIdea is to traverse both trees at the same time and handle merging at a single node before recursively merging the children nodes. \n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nBegin with the root nodes as in the `mergeTrees()` function. Check whether both nodes are not `NULL`. If either nodes is `NULL` then there will be zero future nodes down this branch that need merging since only one of the trees is defined. As a result, return the defined node. If both nodes are defined then add the value of `root2->val` to `root1->val`, this effectively merges the nodes. Now, recurively set the children of `root1` by recursively calling the function. Return `root1`.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO(n) where n is the number of nodes in the larger tree \n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(1) since the function merges the trees inplace.\n\n# Code\n```python3 []\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n\n        # if root1 is undefined return root2\n        if not root1:\n            return root2\n\n        # if root2 is undefined return root1\n        if not root2:\n            return root1\n\n        # merge root2 into root1 then return root1\n        root1.val = root1.val + root2.val\n        root1.left = self.mergeTrees(root1.left, root2.left)\n        root1.right = self.mergeTrees(root1.right, root2.right)\n\n        return root1\n```\n```cpp []\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n\n        // if either node is undefined return the other\n        if (!root1){ return root2; }\n        if (!root2){ return root1; }\n        \n        // if both nodes defined then add root2->val to root1 and merge children\n        TreeNode* ans = new TreeNode();\n        root1->val = root1->val + root2->val;\n        root1->left = mergeTrees(root1->left, root2->left);\n        root1->right = mergeTrees(root1->right, root2->right);\n        \n        return root1;\n    }\n};\n\n```",
            "solution_url": "https://leetcode.com/problems/merge-two-binary-trees/6531830/c-python-recursion-by-jo3-h-nn7a",
            "topics": "Python3",
            "hits": 2,
            "likes": 0,
            "dislikes": 0
        },
        {
            "event_id": 6530873,
            "event_type": "Solution",
            "problem_name": "Zero Array Transformation II",
            "problem_description": "",
            "problem_url": "https://leetcode.com/problems/zero-array-transformation-ii/description/",
            "difficulty": "",
            "timestamp": "2025-03-13T01:48:29.898324+00:00",
            "solution_name": "C++ Solution - Binary Search",
            "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nInitial intuition to find this smallest value `k` would be to set value of `k` to zero and iteratively increase until a valid zero array is formed from processing the first `k` queries. Unfortunately this is far too slow for the requirements.\n\nA more efficient idea would be to binary search values of `k` until the smallest valid value is found. This reduces the complexity of the search to O(log n). \n\nNow we can simply define a function to check whether the current value of `k` will result in a valid Zero Array. Note that this function can be optimized independently.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nThe approach is to take the `minZeroArray()` function and create a binary search for `k`. In doing this, we can set an `int ans` variable whick holds the best answer found so far. On each loop of the binary search, if the midpoint value for `k` creates a valid Zero Array then we can update `ans` and continue moving the binary search bound `left` and `right`.\n\nOnce the bounds `left` and `right` are equal, we can exit the binary search and conclude that `ans` holds the best answer we have found. \n\nThe `isValidZeroArray()` function takes parameter `int k` which is the current value of the binary search. To check for a valid Zero Array we can take each query and decrement the left index of a difference array and increment the right index if its within bounds. After processing each query we check for valid conditions by calculating the cumulative decrement at each position and checking that the total is sufficient to reduce nums[i] to zero. \n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO((m+n) * log (n))\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(n + m)\n\n# Code\n```cpp []\nclass Solution {\nprivate:\n    vector<int> nums;\n    vector<vector<int>> queries;\n    int n;\n\n    bool isValidZeroArray(int k){\n        \n        vector<int> diff(n, 0);\n        for (int i=0; i<k; i++){ // iterate first k queries\n\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            diff[l] -= val;\n            if (r+1 < n){\n                diff[r+1] += val;\n            }\n\n        }\n\n        // check for zero array\n        int total = 0;\n        for (int i=0; i<n; i++){\n            total += diff[i];\n            if (nums[i] + total > 0){ return false; }\n        }\n\n        return true;\n    }\n\npublic:\n    int minZeroArray(vector<int>& _nums, vector<vector<int>>& _queries) {\n\n        // set member variables for access\n        nums = _nums;\n        queries = _queries;\n        n = nums.size();\n\n        // check for array already zero\n        if (isValidZeroArray(0)) {return 0;}\n        \n        // binary search values of 'k' until smallest valid value is found\n        int left = 0;\n        int right = queries.size();\n        int ans = -1;\n        while (left <= right){\n            int k = (left + right) / 2;\n            if (isValidZeroArray(k)){\n                ans = k;\n                right = k - 1;\n            } else {\n                left = k + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n```",
            "solution_url": "https://leetcode.com/problems/zero-array-transformation-ii/6530873/c-solution-binary-search-by-jo3-h-qhpy",
            "topics": "C++",
            "hits": 10,
            "likes": 0,
            "dislikes": 0
        },
        {
            "event_id": 6526045,
            "event_type": "Solution",
            "problem_name": "Maximum Count of Positive Integer and Negative Integer",
            "problem_description": "",
            "problem_url": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/description/",
            "difficulty": "",
            "timestamp": "2025-03-12T00:41:17.212839+00:00",
            "solution_name": "C++ solution; O(n) one pass.",
            "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is to maintain a count of each num in nums that is smaller than zero and larger than zero. Once we have these two numbers we can simply return the larger of the two. \n\nA more efficient method, since the input vector nums is sorted in non_decreasing order, would be to binary search for number 0. Once zero has been found we can use a pointer to find the index of the first number which is above zero and the last number smaller than zero. Using each of these indexes we can simply calculate the elements to the right/left of the position and return the larger of the two. \n\n# Approach\n<!-- Describe your approach to solving the probem. -->\nInitialise two integers to store the count of negative and positive numbers inspected. Iterate through each num in nums and check conditions that num is larger than or smaller than zero. Enumerate counts accordingly.\nReturn the max of the two values.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO(n) Time complexity. Where n is length of input arry nums.\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(1) Space complexity. All cases only use 2 int datatypes to compute.\n\n# Code\n```cpp []\nclass Solution {\npublic:\n    int maximumCount(vector<int>& nums) {\n        int pos = 0;\n        int neg = 0;\n        for (auto n : nums){\n            if (n>0){pos++;}\n            else if (n<0){neg++;}\n        }\n        return max(pos, neg);\n    }\n};\n```",
            "solution_url": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/6526045/c-solution-on-one-pass-by-jo3-h-iidi",
            "topics": "C++",
            "hits": 1,
            "likes": 0,
            "dislikes": 0
        }
    ],
    "summary": [
        {
            "username": "Jo3-h",
            "data": {
                "numAcceptedQuestions": [
                    {
                        "count": 143,
                        "difficulty": "EASY"
                    },
                    {
                        "count": 168,
                        "difficulty": "MEDIUM"
                    },
                    {
                        "count": 15,
                        "difficulty": "HARD"
                    }
                ],
                "numFailedQuestions": [
                    {
                        "count": 2,
                        "difficulty": "EASY"
                    },
                    {
                        "count": 3,
                        "difficulty": "MEDIUM"
                    },
                    {
                        "count": 0,
                        "difficulty": "HARD"
                    }
                ],
                "numUntouchedQuestions": [
                    {
                        "count": 725,
                        "difficulty": "EASY"
                    },
                    {
                        "count": 1648,
                        "difficulty": "MEDIUM"
                    },
                    {
                        "count": 802,
                        "difficulty": "HARD"
                    }
                ],
                "userSessionBeatsPercentage": [
                    {
                        "difficulty": "EASY",
                        "percentage": 95.11
                    },
                    {
                        "difficulty": "MEDIUM",
                        "percentage": 92.04
                    },
                    {
                        "difficulty": "HARD",
                        "percentage": 71.93
                    }
                ],
                "totalQuestionBeatsPercentage": 97.5,
                "ranking": 300239
            }
        }
    ],
    "calendar": {
        "data": {
            "matchedUser": {
                "userCalendar": {
                    "activeYears": [
                        2024,
                        2025
                    ],
                    "streak": 32,
                    "totalActiveDays": 99,
                    "submissionCalendar": "{\"1735776000\": 1, \"1736208000\": 1, \"1736294400\": 2, \"1736380800\": 1, \"1736726400\": 1, \"1736899200\": 2, \"1736985600\": 1, \"1737417600\": 3, \"1737590400\": 2, \"1737676800\": 1, \"1738022400\": 24, \"1738281600\": 5, \"1738454400\": 2, \"1738540800\": 17, \"1738627200\": 11, \"1738713600\": 4, \"1738800000\": 1, \"1738886400\": 21, \"1738972800\": 2, \"1739059200\": 2, \"1739145600\": 10, \"1739232000\": 8, \"1739318400\": 18, \"1739404800\": 4, \"1739491200\": 1, \"1739836800\": 2, \"1740096000\": 1, \"1740355200\": 8, \"1740614400\": 13, \"1740960000\": 6, \"1741046400\": 22, \"1741132800\": 9, \"1741219200\": 7, \"1741305600\": 1, \"1741392000\": 3, \"1741478400\": 1, \"1741564800\": 8, \"1741651200\": 7, \"1741737600\": 3, \"1741824000\": 20, \"1741910400\": 11, \"1741996800\": 4, \"1742083200\": 22, \"1742169600\": 8, \"1742256000\": 14, \"1742342400\": 8, \"1742428800\": 4, \"1742515200\": 5, \"1742601600\": 1, \"1742688000\": 4, \"1742774400\": 1, \"1742860800\": 3, \"1742947200\": 8, \"1743033600\": 1, \"1743120000\": 2, \"1743206400\": 1, \"1743292800\": 2, \"1743379200\": 2, \"1743465600\": 4, \"1743552000\": 7, \"1743638400\": 1, \"1728604800\": 2, \"1728691200\": 2, \"1728777600\": 6, \"1728864000\": 11, \"1728950400\": 6, \"1729036800\": 25, \"1729123200\": 6, \"1729382400\": 4, \"1729468800\": 16, \"1729555200\": 38, \"1729641600\": 16, \"1729728000\": 8, \"1729814400\": 4, \"1729987200\": 5, \"1730073600\": 3, \"1730246400\": 6, \"1730678400\": 10, \"1730764800\": 1, \"1730851200\": 6, \"1730937600\": 1, \"1731283200\": 8, \"1731369600\": 1, \"1731456000\": 1, \"1731888000\": 4, \"1732579200\": 1, \"1732752000\": 4, \"1732838400\": 2, \"1733097600\": 5, \"1733184000\": 5, \"1733356800\": 3, \"1733443200\": 6, \"1733529600\": 2, \"1734307200\": 12, \"1734393600\": 1, \"1734480000\": 2, \"1734566400\": 2, \"1734652800\": 3, \"1734739200\": 2}"
                }
            }
        }
    }
}
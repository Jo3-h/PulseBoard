[
    {
        "event_id": 1591588431,
        "event_type": "Submission",
        "problem_name": "Put Marbles in Bags",
        "problem_description": "<p>You have <code>k</code> bags. You are given a <strong>0-indexed</strong> integer array <code>weights</code> where <code>weights[i]</code> is the weight of the <code>i<sup>th</sup></code> marble. You are also given the integer <code>k.</code></p>\n\n<p>Divide the marbles into the <code>k</code> bags according to the following rules:</p>\n\n<ul>\n\t<li>No bag is empty.</li>\n\t<li>If the <code>i<sup>th</sup></code> marble and <code>j<sup>th</sup></code> marble are in a bag, then all marbles with an index between the <code>i<sup>th</sup></code> and <code>j<sup>th</sup></code> indices should also be in that same bag.</li>\n\t<li>If a bag consists of all the marbles with an index from <code>i</code> to <code>j</code> inclusively, then the cost of the bag is <code>weights[i] + weights[j]</code>.</li>\n</ul>\n\n<p>The <strong>score</strong> after distributing the marbles is the sum of the costs of all the <code>k</code> bags.</p>\n\n<p>Return <em>the <strong>difference</strong> between the <strong>maximum</strong> and <strong>minimum</strong> scores among marble distributions</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> weights = [1,3,5,1], k = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> \nThe distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6. \nThe distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10. \nThus, we return their difference 10 - 6 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> weights = [1, 3], k = 2\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The only distribution possible is [1],[3]. \nSince both the maximal and minimal score are the same, we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= weights.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= weights[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/put-marbles-in-bags/",
        "created_at": "2025-03-31 02:38:57",
        "status": "Accepted",
        "difficulty": "Hard",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Array, Greedy, Sorting, Heap (Priority Queue)",
        "total_accepted": "82K",
        "total_submissions": "118.8K",
        "total_accepted_ratio": "69.0%",
        "hits": 0,
        "likes": 2240,
        "dislikes": 98
    },
    {
        "event_id": 6587967,
        "event_type": "Solution",
        "problem_name": "Maximum Number of Points From Grid Queries",
        "problem_description": "",
        "problem_url": "https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/description/",
        "created_at": "2025-03-28T01:57:10.735408+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ - BFS / Priority Queue",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is to simply search using BFS to solve for each query. Not difficult to implement. However, this is not an optimal approach. The key point to understand in this context is that the initial position is the same for all queries. Once this has been accepted, consider all potential values of `queries[i]`. Since the question states that for a node in the grid to be accessable, the value of `queries[i]` must be strictly larger than the node value, it is true that for any queries `x` and `y` such that `x < y`, the BFS explored nodes for `x` will be a sub-set nodes explored for `y`. \n\nThis condition can be extended. If `queries` is sorted in ascending order, for all elements in `queries` nodes explored in BFS for `queries[i]` will be a sub-set of nodes explored in `queries[i+1]`.\n\nOnce this is realised, a single BFS pass can be constructed for the largest value of `queries[i]`, making sure to explore the smallest valued nodes first. For each value of `queries[i]` once there are no more nodes that have been found that satisfy the condition `queries[i] > grid[x][y]`, push the current answer to the result and contniue the search with the larger value of `queries[i]`.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nFirst, initialise `int m, n` to store the dimensions of the grid. `vector<int> ans` will be used to store the resulting vector. Now, utilise a `vector<pair<int, int>> sortedQueries` to store sorted queries which maintaining references to their original index in `queries`. Sort this by first element. Initialise a priority queue `priority_queue<pair<int, pair<int, int>>> pq` which holds a given node's value along with its position in the martix. Also a boolean matrix the same size as the grid indicating whether a node has been seen yet. Set the inital position (0, 0) to TRUE. Push the starting position to the queue along with its value. \n\nNow, intialise a variable `int currentAns = 0` to store the number of points currently earned. \n\nIterate through each query and while the queue is not empty and the smallest value of a reached node is smaller than the current query, explore the node at the front of the queue. Pop this node from the front of the queue and check the validity of neighbours by checking for out of bounds and whether neighbour has been seen or not. If vaild neighbour then push to queue and set seen as True.\n\nOnce there are no more nodes in the queue that this query can earn points for, set the answer for this query to the current value of `currentAns`. Since the value of query is increasing with each iteration, the currentAns can be carried over to the next query, thus, continue BFS until all queries have been processed and the queue is empty. \n\nReturn the Ans vector.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O(n*m log (n*m))$$\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(m*n)$$\n\n# Code\n```cpp []\nclass Solution {\n\npublic:\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\n        int m = grid.size();\n        int n = grid[0].size();\n        vector<int> ans(queries.size(), 0);\n\n        vector<pair<int, int>> sortedQueries;\n        for (int i=0; i<queries.size(); i++){\n            sortedQueries.push_back({queries[i], i});\n        }\n        sort(sortedQueries.begin(), sortedQueries.end());\n\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;\n        pq.push({grid[0][0], {0,0}});\n\n        vector<vector<bool>> seen(m, vector<bool>(n, false));\n        vector<int> dx = {-1, 1, 0, 0};\n        vector<int> dy = {0, 0, 1, -1};\n        seen[0][0] = true;\n\n        // iterate through each query and explore the reachable nodes that are below the current query value\n        int currentAns = 0;\n        for (auto &[query, index] : sortedQueries){\n\n            while (!pq.empty() && pq.top().first < query){\n\n                auto [value, pos] = pq.top();\n                pq.pop();\n                currentAns++;\n\n                for (int i=0; i<4; i++){\n                    int ny = pos.second + dy[i];\n                    int nx = pos.first + dx[i];\n\n                    if (ny < 0 || ny >= n || nx < 0 || nx >= m || seen[nx][ny]){\n                        continue;\n                    }\n                    seen[nx][ny] = true;\n                    pq.push({grid[nx][ny],{nx, ny}});\n                }\n\n            }\n\n            ans[index] = currentAns;\n\n        }\n\n        return ans;\n    }\n};\n```",
        "solution_url": "https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/6587967/c-bfs-priority-queue-by-jo3-h-xcbb",
        "topics": "Breadth-First Search, Heap (Priority Queue), C++",
        "hits": 15,
        "likes": 0,
        "dislikes": 0
    }
]
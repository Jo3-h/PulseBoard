[
    {
        "event_id": 1593772771,
        "event_type": "Submission",
        "problem_name": "Bitwise AND of Numbers Range",
        "problem_description": "<p>Given two integers <code>left</code> and <code>right</code> that represent the range <code>[left, right]</code>, return <em>the bitwise AND of all numbers in this range, inclusive</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 5, right = 7\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 0, right = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 1, right = 2147483647\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= left &lt;= right &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/bitwise-and-of-numbers-range/",
        "created_at": "2025-04-02 01:00:42",
        "status": "Accepted",
        "difficulty": "Medium",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Bit Manipulation",
        "total_accepted": "446.1K",
        "total_submissions": "938.4K",
        "total_accepted_ratio": "47.5%",
        "hits": 0,
        "likes": 4121,
        "dislikes": 309
    },
    {
        "event_id": 6601600,
        "event_type": "Solution",
        "problem_name": "Solving Questions With Brainpower",
        "problem_description": "",
        "problem_url": "https://leetcode.com/problems/solving-questions-with-brainpower/description/",
        "created_at": "2025-04-01T01:26:04.217897+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ / Python - Dynamic Programming",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nCreate a dynamic programming array to store the best possible score starting at each index. Start at the end of the test initially and work backwards since the best score for a student starting at the last question is simply to do the only available question. Iteratve backwards and calculate whether the current question should be completed or not. This is possible since all questions following the currently inspected question already have their best possible score calculated. \n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nInitialise a dynamic programming array `vector<long long> dp(q, 0)` where `q = questions.size()`. Set the last value in this array to equal the points attainable by completing the final question on the test `dp[q-1] = questions[q-1][0]`. Now, iteratre backwards from the second to last\n\n1. Initialise a dynamic programming array `vector<long long> dp(q, 0)` where `q = questions.size()`.\n2. Set the last value in this array to equal the points attainable by completing the final question on the test `dp[q-1] = questions[q-1][0]`.\n3. Now, iteratre backwards from the second to last question to the first question. Achieve this with the loop `for (int i=q-2; i>=0; i--)`.\n4. For each value of `i`, set variables `int points = questions[i][0]` and `int brainpower = questions[i][1]` as the points and brainpower values for the current i-th question.\n5. Check whether the condition `i + brainpower + 1 < q` is true. This tests whether, if the question is completed, there is another question able to be completed before the test is finished (need this check to not access beyond bounds of question).\n6. If above condition is true then set `dp[i] = max(dp[i+1], points + dp[i + brainpower + 1])`. This reads as the better option of skipping this question and taking the best score starting from question `i + 1` or completing this question and adding the best possible score of the next available question.\n7. If above condition is false, then no other questions can be completed if the current question is completed. As such, the best score at this question will be the `dp[i] = max(points, dp[i+1])`.\n8. Return the best possible score starting from the beginning of the test `dp[0]`\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is the number of questions\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is the number of questions\n\n# Code\n```cpp []\nclass Solution {\npublic:\n    long long mostPoints(vector<vector<int>>& questions) {\n        int q = questions.size();\n        vector<long long> dp(q, 0);\n        dp[q-1] = questions[q-1][0];\n        for (int i = q-2; i >= 0; i--){\n            int points = questions[i][0];\n            int brainpower = questions[i][1];\n            if (i + brainpower + 1 < q){\n                dp[i] = max(dp[i+1], points + dp[i + brainpower + 1]);\n            } else {\n                dp[i] = max(static_cast<long long>(points), dp[i+1]);\n            }\n        }\n        return dp[0];\n    }\n};\n```\n``` python3 []\nclass Solution:\n    def mostPoints(self, questions: List[List[int]]) -> int:\n        q = len(questions)\n        dp = [0] * q\n        dp[-1] = questions[-1][0]\n        for i in range(q - 2, -1, -1):\n            points, brainpower = questions[i]\n            if i + brainpower + 1 < q:\n                dp[i] = max(dp[i+1], points + dp[i+brainpower+1])\n            else:\n                dp[i] = max(points, dp[i+1])\n\n        return dp[0]\n```",
        "solution_url": "https://leetcode.com/problems/solving-questions-with-brainpower/6601600/c-python-dynamic-programming-by-jo3-h-kk5m",
        "total_accepted": 0,
        "total_submissions": 0,
        "total_accepted_ratio": 0,
        "topics": "Array, Dynamic Programming, C++, Python3",
        "hits": 2,
        "likes": 0,
        "dislikes": 0
    }
]
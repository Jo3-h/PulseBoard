[
    {
        "event_id": 1626590858,
        "event_type": "Submission",
        "problem_name": "Build Array from Permutation",
        "problem_description": "<p>Given a <strong>zero-based permutation</strong> <code>nums</code> (<strong>0-indexed</strong>), build an array <code>ans</code> of the <strong>same length</strong> where <code>ans[i] = nums[nums[i]]</code> for each <code>0 &lt;= i &lt; nums.length</code> and return it.</p>\n\n<p>A <strong>zero-based permutation</strong> <code>nums</code> is an array of <strong>distinct</strong> integers from <code>0</code> to <code>nums.length - 1</code> (<strong>inclusive</strong>).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,2,1,5,3,4]\n<strong>Output:</strong> [0,1,2,4,5,3]<strong>\nExplanation:</strong> The array ans is built as follows: \nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]\n    = [0,1,2,4,5,3]</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,0,1,2,3,4]\n<strong>Output:</strong> [4,5,0,1,2,3]\n<strong>Explanation:</strong> The array ans is built as follows:\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]\n    = [4,5,0,1,2,3]</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li>The elements in <code>nums</code> are <strong>distinct</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you solve it without using an extra space (i.e., <code>O(1)</code> memory)?</p>\n",
        "problem_url": "https://leetcode.com/problems/build-array-from-permutation/",
        "created_at": "2025-05-06 02:15:08",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Array, Simulation",
        "total_accepted": "645.5K",
        "total_submissions": "713.8K",
        "total_accepted_ratio": "90.4%",
        "hits": null,
        "likes": 3555,
        "dislikes": 431
    },
    {
        "event_id": 1625916767,
        "event_type": "Submission",
        "problem_name": "Count Largest Group",
        "problem_description": "<p>You are given an integer <code>n</code>.</p>\n\n<p>We need to group the numbers from <code>1</code> to <code>n</code> according to the sum of its digits. For example, the numbers 14 and 5 belong to the <strong>same</strong> group, whereas 13 and 3 belong to <strong>different</strong> groups.</p>\n\n<p>Return the number of groups that have the largest size, i.e. the <strong>maximum</strong> number of elements.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 13\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:\n[1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9].\nThere are 4 groups with largest size.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are 2 groups [1], [2] of size 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/count-largest-group/",
        "created_at": "2025-05-05 07:50:48",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Hash Table, Math",
        "total_accepted": "167K",
        "total_submissions": "222.4K",
        "total_accepted_ratio": "75.1%",
        "hits": null,
        "likes": 759,
        "dislikes": 1174
    },
    {
        "event_id": 1621517863,
        "event_type": "Submission",
        "problem_name": "Find Numbers with Even Number of Digits",
        "problem_description": "<p>Given an array <code>nums</code> of integers, return how many of them contain an <strong>even number</strong> of digits.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [12,345,2,6,7896]\n<strong>Output:</strong> 2\n<strong>Explanation: \n</strong>12 contains 2 digits (even number of digits).&nbsp;\n345 contains 3 digits (odd number of digits).&nbsp;\n2 contains 1 digit (odd number of digits).&nbsp;\n6 contains 1 digit (odd number of digits).&nbsp;\n7896 contains 4 digits (even number of digits).&nbsp;\nTherefore only 12 and 7896 contain an even number of digits.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [555,901,482,1771]\n<strong>Output:</strong> 1 \n<strong>Explanation: </strong>\nOnly 1771 contains an even number of digits.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/find-numbers-with-even-number-of-digits/",
        "created_at": "2025-04-30 00:06:06",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Array, Math",
        "total_accepted": "916.5K",
        "total_submissions": "1.2M",
        "total_accepted_ratio": "79.3%",
        "hits": null,
        "likes": 2749,
        "dislikes": 136
    },
    {
        "event_id": 1620956869,
        "event_type": "Submission",
        "problem_name": "Reverse String II",
        "problem_description": "<p>Given a string <code>s</code> and an integer <code>k</code>, reverse the first <code>k</code> characters for every <code>2k</code> characters counting from the start of the string.</p>\n\n<p>If there are fewer than <code>k</code> characters left, reverse all of them. If there are less than <code>2k</code> but greater than or equal to <code>k</code> characters, then reverse the first <code>k</code> characters and leave the other as original.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"abcdefg\", k = 2\n<strong>Output:</strong> \"bacdfeg\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"abcd\", k = 2\n<strong>Output:</strong> \"bacd\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of only lowercase English letters.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/reverse-string-ii/",
        "created_at": "2025-04-29 09:13:01",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Two Pointers, String",
        "total_accepted": "302.5K",
        "total_submissions": "582.3K",
        "total_accepted_ratio": "52.0%",
        "hits": null,
        "likes": 2124,
        "dislikes": 4094
    },
    {
        "event_id": 1606381691,
        "event_type": "Submission",
        "problem_name": "Count Good Triplets",
        "problem_description": "<p>Given an array of integers <code>arr</code>, and three integers&nbsp;<code>a</code>,&nbsp;<code>b</code>&nbsp;and&nbsp;<code>c</code>. You need to find the number of good triplets.</p>\r\n\r\n<p>A triplet <code>(arr[i], arr[j], arr[k])</code>&nbsp;is <strong>good</strong> if the following conditions are true:</p>\r\n\r\n<ul>\r\n\t<li><code>0 &lt;= i &lt; j &lt; k &lt;&nbsp;arr.length</code></li>\r\n\t<li><code>|arr[i] - arr[j]| &lt;= a</code></li>\r\n\t<li><code>|arr[j] - arr[k]| &lt;= b</code></li>\r\n\t<li><code>|arr[i] - arr[k]| &lt;= c</code></li>\r\n</ul>\r\n\r\n<p>Where <code>|x|</code> denotes the absolute value of <code>x</code>.</p>\r\n\r\n<p>Return<em> the number of good triplets</em>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong>&nbsp;There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)].\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> arr = [1,1,2,2,3], a = 0, b = 0, c = 1\r\n<strong>Output:</strong> 0\r\n<strong>Explanation: </strong>No triplet satisfies all conditions.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>3 &lt;= arr.length &lt;= 100</code></li>\r\n\t<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>\r\n\t<li><code>0 &lt;= a, b, c &lt;= 1000</code></li>\r\n</ul>",
        "problem_url": "https://leetcode.com/problems/count-good-triplets/",
        "created_at": "2025-04-14 08:16:20",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Array, Enumeration",
        "total_accepted": "260.3K",
        "total_submissions": "304.6K",
        "total_accepted_ratio": "85.5%",
        "hits": null,
        "likes": 1147,
        "dislikes": 1244
    },
    {
        "event_id": 1604218192,
        "event_type": "Submission",
        "problem_name": "Power of Three",
        "problem_description": "<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of three. Otherwise, return <code>false</code></em>.</p>\n\n<p>An integer <code>n</code> is a power of three, if there exists an integer <code>x</code> such that <code>n == 3<sup>x</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 27\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 27 = 3<sup>3</sup>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no x where 3<sup>x</sup> = 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = -1\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no x where 3<sup>x</sup> = (-1).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without loops/recursion?",
        "problem_url": "https://leetcode.com/problems/power-of-three/",
        "created_at": "2025-04-12 05:32:44",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Math, Recursion",
        "total_accepted": "1M",
        "total_submissions": "2.1M",
        "total_accepted_ratio": "47.9%",
        "hits": null,
        "likes": 3243,
        "dislikes": 291
    },
    {
        "event_id": 1603123733,
        "event_type": "Submission",
        "problem_name": "Find the Difference",
        "problem_description": "<p>You are given two strings <code>s</code> and <code>t</code>.</p>\n\n<p>String <code>t</code> is generated by random shuffling string <code>s</code> and then add one more letter at a random position.</p>\n\n<p>Return the letter that was added to <code>t</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;abcde&quot;\n<strong>Output:</strong> &quot;e&quot;\n<strong>Explanation:</strong> &#39;e&#39; is the letter that was added.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;&quot;, t = &quot;y&quot;\n<strong>Output:</strong> &quot;y&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>t.length == s.length + 1</code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/find-the-difference/",
        "created_at": "2025-04-10 22:20:19",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Hash Table, String, Bit Manipulation, Sorting",
        "total_accepted": "892.2K",
        "total_submissions": "1.5M",
        "total_accepted_ratio": "59.7%",
        "hits": null,
        "likes": 5195,
        "dislikes": 495
    },
    {
        "event_id": 1603120968,
        "event_type": "Submission",
        "problem_name": "First Unique Character in a String",
        "problem_description": "<p>Given a string <code>s</code>, find the <strong>first</strong> non-repeating character in it and return its index. If it <strong>does not</strong> exist, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;leetcode&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The character <code>&#39;l&#39;</code> at index 0 is the first character that does not occur at any other index.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;loveleetcode&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;aabb&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">-1</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of only lowercase English letters.</li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/first-unique-character-in-a-string/",
        "created_at": "2025-04-10 22:13:32",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Hash Table, String, Queue, Counting",
        "total_accepted": "2M",
        "total_submissions": "3.1M",
        "total_accepted_ratio": "63.5%",
        "hits": null,
        "likes": 9264,
        "dislikes": 312
    },
    {
        "event_id": 1601146871,
        "event_type": "Submission",
        "problem_name": "Minimum Operations to Make Array Values Equal to K",
        "problem_description": "<p>You are given an integer array <code>nums</code> and an integer <code>k</code>.</p>\n\n<p>An integer <code>h</code> is called <strong>valid</strong> if all values in the array that are <strong>strictly greater</strong> than <code>h</code> are <em>identical</em>.</p>\n\n<p>For example, if <code>nums = [10, 8, 10, 8]</code>, a <strong>valid</strong> integer is <code>h = 9</code> because all <code>nums[i] &gt; 9</code>&nbsp;are equal to 10, but 5 is not a <strong>valid</strong> integer.</p>\n\n<p>You are allowed to perform the following operation on <code>nums</code>:</p>\n\n<ul>\n\t<li>Select an integer <code>h</code> that is <em>valid</em> for the <strong>current</strong> values in <code>nums</code>.</li>\n\t<li>For each index <code>i</code> where <code>nums[i] &gt; h</code>, set <code>nums[i]</code> to <code>h</code>.</li>\n</ul>\n\n<p>Return the <strong>minimum</strong> number of operations required to make every element in <code>nums</code> <strong>equal</strong> to <code>k</code>. If it is impossible to make all elements equal to <code>k</code>, return -1.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [5,2,5,4,5], k = 2</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The operations can be performed in order using valid integers 4 and then 2.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [2,1,2], k = 2</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">-1</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>It is impossible to make all the values equal to 2.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [9,7,5,3], k = 1</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">4</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The operations can be performed using valid integers in the order 7, 5, 3, and 1.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100 </code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/minimum-operations-to-make-array-values-equal-to-k/",
        "created_at": "2025-04-09 00:37:13",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Array, Hash Table",
        "total_accepted": "159.8K",
        "total_submissions": "217.5K",
        "total_accepted_ratio": "73.5%",
        "hits": null,
        "likes": 387,
        "dislikes": 500
    },
    {
        "event_id": 1600077901,
        "event_type": "Submission",
        "problem_name": "Minimum Number of Operations to Make Elements in Array Distinct",
        "problem_description": "<p>You are given an integer array <code>nums</code>. You need to ensure that the elements in the array are <strong>distinct</strong>. To achieve this, you can perform the following operation any number of times:</p>\n\n<ul>\n\t<li>Remove 3 elements from the beginning of the array. If the array has fewer than 3 elements, remove all remaining elements.</li>\n</ul>\n\n<p><strong>Note</strong> that an empty array is considered to have distinct elements. Return the <strong>minimum</strong> number of operations needed to make the elements in the array distinct.<!-- notionvc: 210ee4f2-90af-4cdf-8dbc-96d1fa8f67c7 --></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [1,2,3,4,2,3,3,5,7]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">2</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>In the first operation, the first 3 elements are removed, resulting in the array <code>[4, 2, 3, 3, 5, 7]</code>.</li>\n\t<li>In the second operation, the next 3 elements are removed, resulting in the array <code>[3, 5, 7]</code>, which has distinct elements.</li>\n</ul>\n\n<p>Therefore, the answer is 2.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [4,5,6,4,4]</span></p>\n\n<p><strong>Output:</strong> 2</p>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li>In the first operation, the first 3 elements are removed, resulting in the array <code>[4, 4]</code>.</li>\n\t<li>In the second operation, all remaining elements are removed, resulting in an empty array.</li>\n</ul>\n\n<p>Therefore, the answer is 2.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [6,7,8,9]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The array already contains distinct elements. Therefore, the answer is 0.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/minimum-number-of-operations-to-make-elements-in-array-distinct/",
        "created_at": "2025-04-08 00:12:44",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Array, Hash Table",
        "total_accepted": "170.7K",
        "total_submissions": "238.6K",
        "total_accepted_ratio": "71.6%",
        "hits": null,
        "likes": 528,
        "dislikes": 29
    },
    {
        "event_id": 1600066174,
        "event_type": "Submission",
        "problem_name": "Fibonacci Number",
        "problem_description": "<p>The <b>Fibonacci numbers</b>, commonly denoted <code>F(n)</code> form a sequence, called the <b>Fibonacci sequence</b>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p>\n\n<pre>\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n &gt; 1.\n</pre>\n\n<p>Given <code>n</code>, calculate <code>F(n)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> F(2) = F(1) + F(0) = 1 + 0 = 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> F(3) = F(2) + F(1) = 1 + 1 = 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> F(4) = F(3) + F(2) = 2 + 1 = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 30</code></li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/fibonacci-number/",
        "created_at": "2025-04-07 23:45:44",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Math, Dynamic Programming, Recursion, Memoization",
        "total_accepted": "2.4M",
        "total_submissions": "3.2M",
        "total_accepted_ratio": "72.8%",
        "hits": null,
        "likes": 8663,
        "dislikes": 383
    },
    {
        "event_id": 1599056598,
        "event_type": "Submission",
        "problem_name": "Partition Equal Subset Sum",
        "problem_description": "<p>Given an integer array <code>nums</code>, return <code>true</code> <em>if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,11,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The array can be partitioned as [1, 5, 5] and [11].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,5]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The array cannot be partitioned into equal sum subsets.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/partition-equal-subset-sum/",
        "created_at": "2025-04-07 01:40:33",
        "status": "Accepted",
        "difficulty": "Medium",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Array, Dynamic Programming",
        "total_accepted": "1.2M",
        "total_submissions": "2.5M",
        "total_accepted_ratio": "48.3%",
        "hits": null,
        "likes": 13159,
        "dislikes": 279
    },
    {
        "event_id": 1598203105,
        "event_type": "Submission",
        "problem_name": "Largest Divisible Subset",
        "problem_description": "<p>Given a set of <strong>distinct</strong> positive integers <code>nums</code>, return the largest subset <code>answer</code> such that every pair <code>(answer[i], answer[j])</code> of elements in this subset satisfies:</p>\n\n<ul>\n\t<li><code>answer[i] % answer[j] == 0</code>, or</li>\n\t<li><code>answer[j] % answer[i] == 0</code></li>\n</ul>\n\n<p>If there are multiple solutions, return any of them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> [1,3] is also accepted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,4,8]\n<strong>Output:</strong> [1,2,4,8]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>9</sup></code></li>\n\t<li>All the integers in <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/largest-divisible-subset/",
        "created_at": "2025-04-06 05:58:27",
        "status": "Accepted",
        "difficulty": "Medium",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Array, Math, Dynamic Programming, Sorting",
        "total_accepted": "433.7K",
        "total_submissions": "889.8K",
        "total_accepted_ratio": "48.7%",
        "hits": null,
        "likes": 6567,
        "dislikes": 320
    },
    {
        "event_id": 1597022426,
        "event_type": "Submission",
        "problem_name": "Sort List",
        "problem_description": "<p>Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg\" style=\"width: 450px; height: 194px;\" />\n<pre>\n<strong>Input:</strong> head = [4,2,1,3]\n<strong>Output:</strong> [1,2,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg\" style=\"width: 550px; height: 184px;\" />\n<pre>\n<strong>Input:</strong> head = [-1,5,3,4,0]\n<strong>Output:</strong> [-1,0,3,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?</p>\n",
        "problem_url": "https://leetcode.com/problems/sort-list/",
        "created_at": "2025-04-05 00:53:58",
        "status": "Accepted",
        "difficulty": "Medium",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Linked List, Two Pointers, Divide and Conquer, Sorting, Merge Sort",
        "total_accepted": "1M",
        "total_submissions": "1.7M",
        "total_accepted_ratio": "61.4%",
        "hits": null,
        "likes": 12266,
        "dislikes": 386
    },
    {
        "event_id": 1597012580,
        "event_type": "Submission",
        "problem_name": "Sum of All Subset XOR Totals",
        "problem_description": "<p>The <strong>XOR total</strong> of an array is defined as the bitwise <code>XOR</code> of<strong> all its elements</strong>, or <code>0</code> if the array is<strong> empty</strong>.</p>\n\n<ul>\n\t<li>For example, the <strong>XOR total</strong> of the array <code>[2,5,6]</code> is <code>2 XOR 5 XOR 6 = 1</code>.</li>\n</ul>\n\n<p>Given an array <code>nums</code>, return <em>the <strong>sum</strong> of all <strong>XOR totals</strong> for every <strong>subset</strong> of </em><code>nums</code>.&nbsp;</p>\n\n<p><strong>Note:</strong> Subsets with the <strong>same</strong> elements should be counted <strong>multiple</strong> times.</p>\n\n<p>An array <code>a</code> is a <strong>subset</strong> of an array <code>b</code> if <code>a</code> can be obtained from <code>b</code> by deleting some (possibly zero) elements of <code>b</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3]\n<strong>Output:</strong> 6\n<strong>Explanation: </strong>The 4 subsets of [1,3] are:\n- The empty subset has an XOR total of 0.\n- [1] has an XOR total of 1.\n- [3] has an XOR total of 3.\n- [1,3] has an XOR total of 1 XOR 3 = 2.\n0 + 1 + 3 + 2 = 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,1,6]\n<strong>Output:</strong> 28\n<strong>Explanation: </strong>The 8 subsets of [5,1,6] are:\n- The empty subset has an XOR total of 0.\n- [5] has an XOR total of 5.\n- [1] has an XOR total of 1.\n- [6] has an XOR total of 6.\n- [5,1] has an XOR total of 5 XOR 1 = 4.\n- [5,6] has an XOR total of 5 XOR 6 = 3.\n- [1,6] has an XOR total of 1 XOR 6 = 7.\n- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.\n0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,5,6,7,8]\n<strong>Output:</strong> 480\n<strong>Explanation:</strong> The sum of all XOR totals for every subset is 480.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 12</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 20</code></li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/sum-of-all-subset-xor-totals/",
        "created_at": "2025-04-05 00:22:58",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Array, Math, Backtracking, Bit Manipulation, Combinatorics, Enumeration",
        "total_accepted": "312.9K",
        "total_submissions": "347.4K",
        "total_accepted_ratio": "90.1%",
        "hits": null,
        "likes": 2560,
        "dislikes": 320
    },
    {
        "event_id": 1596097587,
        "event_type": "Submission",
        "problem_name": "Find K Pairs with Smallest Sums",
        "problem_description": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> sorted in <strong>non-decreasing&nbsp;order</strong> and an integer <code>k</code>.</p>\n\n<p>Define a pair <code>(u, v)</code> which consists of one element from the first array and one element from the second array.</p>\n\n<p>Return <em>the</em> <code>k</code> <em>pairs</em> <code>(u<sub>1</sub>, v<sub>1</sub>), (u<sub>2</sub>, v<sub>2</sub>), ..., (u<sub>k</sub>, v<sub>k</sub>)</code> <em>with the smallest sums</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n<strong>Output:</strong> [[1,2],[1,4],[1,6]]\n<strong>Explanation:</strong> The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n<strong>Output:</strong> [[1,1],[1,1]]\n<strong>Explanation:</strong> The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums1</code> and <code>nums2</code> both are sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>k &lt;=&nbsp;nums1.length *&nbsp;nums2.length</code></li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/find-k-pairs-with-smallest-sums/",
        "created_at": "2025-04-04 00:58:19",
        "status": "Accepted",
        "difficulty": "Medium",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Array, Heap (Priority Queue)",
        "total_accepted": "370.9K",
        "total_submissions": "913.6K",
        "total_accepted_ratio": "40.6%",
        "hits": null,
        "likes": 6583,
        "dislikes": 471
    },
    {
        "event_id": 1596087138,
        "event_type": "Submission",
        "problem_name": "Lowest Common Ancestor of Deepest Leaves",
        "problem_description": "<p>Given the <code>root</code> of a binary tree, return <em>the lowest common ancestor of its deepest leaves</em>.</p>\n\n<p>Recall that:</p>\n\n<ul>\n\t<li>The node of a binary tree is a leaf if and only if it has no children</li>\n\t<li>The depth of the root of the tree is <code>0</code>. if the depth of a node is <code>d</code>, the depth of each of its children is <code>d + 1</code>.</li>\n\t<li>The lowest common ancestor of a set <code>S</code> of nodes, is the node <code>A</code> with the largest depth such that every node in <code>S</code> is in the subtree with root <code>A</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"width: 600px; height: 510px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4]\n<strong>Output:</strong> [2,7,4]\n<strong>Explanation:</strong> We return the node with value 2, colored in yellow in the diagram.\nThe nodes coloured in blue are the deepest leaf-nodes of the tree.\nNote that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> The root is the deepest node in the tree, and it&#39;s the lca of itself.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0,1,3,null,2]\n<strong>Output:</strong> [2]\n<strong>Explanation:</strong> The deepest leaf node in the tree is 2, the lca of one node is itself.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree will be in the range <code>[1, 1000]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>The values of the nodes in the tree are <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as 865: <a href=\"https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/\" target=\"_blank\">https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/</a></p>\n",
        "problem_url": "https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/",
        "created_at": "2025-04-04 00:31:45",
        "status": "Accepted",
        "difficulty": "Medium",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Hash Table, Tree, Depth-First Search, Breadth-First Search, Binary Tree",
        "total_accepted": "225.9K",
        "total_submissions": "286.4K",
        "total_accepted_ratio": "78.9%",
        "hits": null,
        "likes": 2532,
        "dislikes": 941
    },
    {
        "event_id": 1595299170,
        "event_type": "Submission",
        "problem_name": "Maximum Depth of N-ary Tree",
        "problem_description": "<p>Given a n-ary tree, find its maximum depth.</p>\n\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n\n<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The total number of nodes is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li>The depth of the n-ary tree is less than or equal to <code>1000</code>.</li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/maximum-depth-of-n-ary-tree/",
        "created_at": "2025-04-03 07:04:11",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Tree, Depth-First Search, Breadth-First Search",
        "total_accepted": "319.4K",
        "total_submissions": "438.6K",
        "total_accepted_ratio": "72.8%",
        "hits": null,
        "likes": 2822,
        "dislikes": 91
    },
    {
        "event_id": 1595295601,
        "event_type": "Submission",
        "problem_name": "Diameter of Binary Tree",
        "problem_description": "<p>Given the <code>root</code> of a binary tree, return <em>the length of the <strong>diameter</strong> of the tree</em>.</p>\n\n<p>The <strong>diameter</strong> of a binary tree is the <strong>length</strong> of the longest path between any two nodes in a tree. This path may or may not pass through the <code>root</code>.</p>\n\n<p>The <strong>length</strong> of a path between two nodes is represented by the number of edges between them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,2]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/diameter-of-binary-tree/",
        "created_at": "2025-04-03 06:59:46",
        "status": "Accepted",
        "difficulty": "Easy",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Tree, Depth-First Search, Binary Tree",
        "total_accepted": "2M",
        "total_submissions": "3.1M",
        "total_accepted_ratio": "63.3%",
        "hits": null,
        "likes": 14671,
        "dislikes": 1158
    },
    {
        "event_id": 1595004511,
        "event_type": "Submission",
        "problem_name": "Maximum Value of an Ordered Triplet II",
        "problem_description": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>.</p>\n\n<p>Return <em><strong>the maximum value over all triplets of indices</strong></em> <code>(i, j, k)</code> <em>such that</em> <code>i &lt; j &lt; k</code><em>. </em>If all such triplets have a negative value, return <code>0</code>.</p>\n\n<p>The <strong>value of a triplet of indices</strong> <code>(i, j, k)</code> is equal to <code>(nums[i] - nums[j]) * nums[k]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [12,6,1,2,7]\n<strong>Output:</strong> 77\n<strong>Explanation:</strong> The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.\nIt can be shown that there are no ordered triplets of indices with a value greater than 77. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,10,3,4,19]\n<strong>Output:</strong> 133\n<strong>Explanation:</strong> The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.\nIt can be shown that there are no ordered triplets of indices with a value greater than 133.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "problem_url": "https://leetcode.com/problems/maximum-value-of-an-ordered-triplet-ii/",
        "created_at": "2025-04-03 00:16:13",
        "status": "Accepted",
        "difficulty": "Medium",
        "solution_name": "",
        "solution_content": "",
        "solution_url": "",
        "topics": "Array",
        "total_accepted": "151.3K",
        "total_submissions": "266.7K",
        "total_accepted_ratio": "56.7%",
        "hits": null,
        "likes": 792,
        "dislikes": 20
    },
    {
        "event_id": 6612884,
        "event_type": "Solution",
        "problem_name": "Lowest Common Ancestor of Deepest Leaves",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/description/",
        "created_at": "2025-04-04T00:53:05.955005+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ - DFS Tree Traversal",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nImagine an arbitrary node in the tree. Given this node, there will be a left and right subtree attached to it (possibly NULL). These subtrees both have some max depth which can be recursively found. Let the max depth of the left and right subtrees be 'L' and 'R' respectfully. Once L and R are obtained, check for the following conditions...\n\n 1. L and R are equal\n 2. L is larger than R\n 3. R is larger than L\n\nIf condition 1 is satisfied, then the current node is the lowest common ancestor of deepest leaves. If condition 2 is satisfied, then then lowest common ancestor of deepest leaves exists in the left subtree of node. Similarly, if condition 3 is satisfied, then the lowest common ancestor of deepest leaves exists in right subtree of node. Recursively perform this process until L and R are equal or a leaf is reached. \n\nIt is worth noting that this does not work if an exhaustive search is employed. In the case which all nodes are inspected, there will be 'local results' in which the condition that the depth of the left and right subtrees are equal. In this algorithm, these local results are pruned out by traversing the tree in a greedy fashion and only inspecting the subtree with the larger depth. \n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nDefine two member methods to assist in solving this problem...\n\n`int getDepth(TreeNode* node)` takes a TreeNode pointer as input and returns the maximum depth of a subtree starting at this node. If node is NULL then the depth is 0, else return 1 + the maximum depth of the children of node.\n\n`void dfs(TreeNode* node)` takes a TreeNode pointer and performs the logic of the intuition. If the input node is a leaf then set the ans member variable as input node and return. Else, calculate L and R. Apply logic to check the 3 conditions as per above. Traverse the tree in the outlined fashion and recursively call dfs function if needed. \n\nOnce these two methods have been defined, simply call dfs on root node and return the values of member variable ans.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O(log(n))$$\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(1)$$\n\n# Code\n```cpp []\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    TreeNode* ans = nullptr;\n    void dfs(TreeNode* node){\n\n        if (!node->left && !node->right){\n            ans = node;\n            return;\n        }\n        \n        int L = getDepth(node->left);\n        int R = getDepth(node->right);\n        if (L == R){\n            ans = node;\n            return;\n        } else if (L < R){\n            dfs(node->right);\n        } else {\n            dfs(node->left);\n        }\n        return;\n\n    }\n    int getDepth(TreeNode* node){\n        if (!node){ return 0; }\n        return 1 + max(getDepth(node->left), getDepth(node->right));\n    }\n\npublic:\n    TreeNode* lcaDeepestLeaves(TreeNode* root) {\n\n        // base conditions\n        if (!root){return nullptr;}\n        if (!root->left && !root->right){return root;}\n\n        dfs(root);\n\n        return ans;\n    }\n};\n```",
        "solution_url": "https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/6612884/c-dfs-tree-traversal-by-jo3-h-5zf5",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "Tree, Depth-First Search, Binary Tree, C++",
        "hits": 11,
        "likes": 0,
        "dislikes": 0
    },
    {
        "event_id": 6601600,
        "event_type": "Solution",
        "problem_name": "Solving Questions With Brainpower",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/solving-questions-with-brainpower/description/",
        "created_at": "2025-04-01T01:26:04.217897+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ / Python - Dynamic Programming",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nCreate a dynamic programming array to store the best possible score starting at each index. Start at the end of the test initially and work backwards since the best score for a student starting at the last question is simply to do the only available question. Iteratve backwards and calculate whether the current question should be completed or not. This is possible since all questions following the currently inspected question already have their best possible score calculated. \n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nInitialise a dynamic programming array `vector<long long> dp(q, 0)` where `q = questions.size()`. Set the last value in this array to equal the points attainable by completing the final question on the test `dp[q-1] = questions[q-1][0]`. Now, iteratre backwards from the second to last\n\n1. Initialise a dynamic programming array `vector<long long> dp(q, 0)` where `q = questions.size()`.\n2. Set the last value in this array to equal the points attainable by completing the final question on the test `dp[q-1] = questions[q-1][0]`.\n3. Now, iteratre backwards from the second to last question to the first question. Achieve this with the loop `for (int i=q-2; i>=0; i--)`.\n4. For each value of `i`, set variables `int points = questions[i][0]` and `int brainpower = questions[i][1]` as the points and brainpower values for the current i-th question.\n5. Check whether the condition `i + brainpower + 1 < q` is true. This tests whether, if the question is completed, there is another question able to be completed before the test is finished (need this check to not access beyond bounds of question).\n6. If above condition is true then set `dp[i] = max(dp[i+1], points + dp[i + brainpower + 1])`. This reads as the better option of skipping this question and taking the best score starting from question `i + 1` or completing this question and adding the best possible score of the next available question.\n7. If above condition is false, then no other questions can be completed if the current question is completed. As such, the best score at this question will be the `dp[i] = max(points, dp[i+1])`.\n8. Return the best possible score starting from the beginning of the test `dp[0]`\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is the number of questions\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is the number of questions\n\n# Code\n```cpp []\nclass Solution {\npublic:\n    long long mostPoints(vector<vector<int>>& questions) {\n        int q = questions.size();\n        vector<long long> dp(q, 0);\n        dp[q-1] = questions[q-1][0];\n        for (int i = q-2; i >= 0; i--){\n            int points = questions[i][0];\n            int brainpower = questions[i][1];\n            if (i + brainpower + 1 < q){\n                dp[i] = max(dp[i+1], points + dp[i + brainpower + 1]);\n            } else {\n                dp[i] = max(static_cast<long long>(points), dp[i+1]);\n            }\n        }\n        return dp[0];\n    }\n};\n```\n``` python3 []\nclass Solution:\n    def mostPoints(self, questions: List[List[int]]) -> int:\n        q = len(questions)\n        dp = [0] * q\n        dp[-1] = questions[-1][0]\n        for i in range(q - 2, -1, -1):\n            points, brainpower = questions[i]\n            if i + brainpower + 1 < q:\n                dp[i] = max(dp[i+1], points + dp[i+brainpower+1])\n            else:\n                dp[i] = max(points, dp[i+1])\n\n        return dp[0]\n```",
        "solution_url": "https://leetcode.com/problems/solving-questions-with-brainpower/6601600/c-python-dynamic-programming-by-jo3-h-kk5m",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "Array, Dynamic Programming, C++, Python3",
        "hits": 2,
        "likes": 0,
        "dislikes": 0
    },
    {
        "event_id": 6587967,
        "event_type": "Solution",
        "problem_name": "Maximum Number of Points From Grid Queries",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/description/",
        "created_at": "2025-03-28T01:57:10.735408+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ - BFS / Priority Queue",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is to simply search using BFS to solve for each query. Not difficult to implement. However, this is not an optimal approach. The key point to understand in this context is that the initial position is the same for all queries. Once this has been accepted, consider all potential values of `queries[i]`. Since the question states that for a node in the grid to be accessable, the value of `queries[i]` must be strictly larger than the node value, it is true that for any queries `x` and `y` such that `x < y`, the BFS explored nodes for `x` will be a sub-set nodes explored for `y`. \n\nThis condition can be extended. If `queries` is sorted in ascending order, for all elements in `queries` nodes explored in BFS for `queries[i]` will be a sub-set of nodes explored in `queries[i+1]`.\n\nOnce this is realised, a single BFS pass can be constructed for the largest value of `queries[i]`, making sure to explore the smallest valued nodes first. For each value of `queries[i]` once there are no more nodes that have been found that satisfy the condition `queries[i] > grid[x][y]`, push the current answer to the result and contniue the search with the larger value of `queries[i]`.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nFirst, initialise `int m, n` to store the dimensions of the grid. `vector<int> ans` will be used to store the resulting vector. Now, utilise a `vector<pair<int, int>> sortedQueries` to store sorted queries which maintaining references to their original index in `queries`. Sort this by first element. Initialise a priority queue `priority_queue<pair<int, pair<int, int>>> pq` which holds a given node's value along with its position in the martix. Also a boolean matrix the same size as the grid indicating whether a node has been seen yet. Set the inital position (0, 0) to TRUE. Push the starting position to the queue along with its value. \n\nNow, intialise a variable `int currentAns = 0` to store the number of points currently earned. \n\nIterate through each query and while the queue is not empty and the smallest value of a reached node is smaller than the current query, explore the node at the front of the queue. Pop this node from the front of the queue and check the validity of neighbours by checking for out of bounds and whether neighbour has been seen or not. If vaild neighbour then push to queue and set seen as True.\n\nOnce there are no more nodes in the queue that this query can earn points for, set the answer for this query to the current value of `currentAns`. Since the value of query is increasing with each iteration, the currentAns can be carried over to the next query, thus, continue BFS until all queries have been processed and the queue is empty. \n\nReturn the Ans vector.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O(n*m log (n*m))$$\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(m*n)$$\n\n# Code\n```cpp []\nclass Solution {\n\npublic:\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\n        int m = grid.size();\n        int n = grid[0].size();\n        vector<int> ans(queries.size(), 0);\n\n        vector<pair<int, int>> sortedQueries;\n        for (int i=0; i<queries.size(); i++){\n            sortedQueries.push_back({queries[i], i});\n        }\n        sort(sortedQueries.begin(), sortedQueries.end());\n\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;\n        pq.push({grid[0][0], {0,0}});\n\n        vector<vector<bool>> seen(m, vector<bool>(n, false));\n        vector<int> dx = {-1, 1, 0, 0};\n        vector<int> dy = {0, 0, 1, -1};\n        seen[0][0] = true;\n\n        // iterate through each query and explore the reachable nodes that are below the current query value\n        int currentAns = 0;\n        for (auto &[query, index] : sortedQueries){\n\n            while (!pq.empty() && pq.top().first < query){\n\n                auto [value, pos] = pq.top();\n                pq.pop();\n                currentAns++;\n\n                for (int i=0; i<4; i++){\n                    int ny = pos.second + dy[i];\n                    int nx = pos.first + dx[i];\n\n                    if (ny < 0 || ny >= n || nx < 0 || nx >= m || seen[nx][ny]){\n                        continue;\n                    }\n                    seen[nx][ny] = true;\n                    pq.push({grid[nx][ny],{nx, ny}});\n                }\n\n            }\n\n            ans[index] = currentAns;\n\n        }\n\n        return ans;\n    }\n};\n```",
        "solution_url": "https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/6587967/c-bfs-priority-queue-by-jo3-h-xcbb",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "Breadth-First Search, Heap (Priority Queue), C++",
        "hits": 16,
        "likes": 0,
        "dislikes": 0
    },
    {
        "event_id": 6583957,
        "event_type": "Solution",
        "problem_name": "Minimum Index of a Valid Split",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/minimum-index-of-a-valid-split/description/",
        "created_at": "2025-03-27T00:57:16.996466+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ - Precompute dominantCount subarray",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is to check all candidate values of `i` which could potentially lead to a valid split. Return the first one found since `i` is enumerated upwards. If no valid `i` is found, return `-1`.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nAbstract the functionality for computing the `dominantElement` and precomputing the count of this element at each index to functions `getDominant(vector<int>)` and `precomputeDominantCount(vector<int>, int)` respectively.\n\n-`getDominant(vector<int>& nums)`\nThis function works by harnessing an unordered_map `unordered_map<int, int> freq` which will function as a freqency map storing each element and its count of occurances in input num. Also, initialise `int maxFreq = 0` and `int maxElement = nums[0]` to store the best found element and frequency. Iterate elements of nums and enumerate the value of `freq[num]` and check whether this has become the most frequent element. Upon finding the most frequent element, check whether it is more than half of the elements in the array. If so, return `maxElement` else return `-1`.\n\n-`precomputeDominantCount(vector<int>& nums, int dominant)`\nThis function works by initialising a vector<int> `ans` which matches the size of nums and stores an array of 0s. Iterate through nums and for each element in index `i`, if condition `nums[i] == dominant` evaluates to `true` then the count of dominant to index `i` is `ans[i] = ans[i-1] + 1` else `ans[i] = ans[i-1]`.\n\nOnce these have been set up, move to checking for valid candidate `i` values. Iterate `i` and calculate the number of occurances of `dominant` in the left subarray by setting `leftCount = dominantCount[i]` and the right subarray by setting `rightCount = dominantEnd - dominantCount[i]`. If these two values are larger than half of the size of each subarray respectively, then return `i`. If no valid value is found, return `-1`. \n\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is size of input array\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is size of input array\n\n# Code\n```cpp []\nclass Solution {\nprivate:\n    vector<int> precomputeDominantCount(vector<int>& nums, int dominant){\n        vector<int> ans(nums.size(), 0);\n        if (nums[0] == dominant){ ans[0] = 1; }\n        for (int i=1; i<nums.size(); i++){\n            if (nums[i] == dominant){\n                ans[i] = ans[i-1] + 1;\n            } else {\n                ans[i] = ans[i-1];\n            }\n        }\n        return ans;\n    }\n\n    int getDominant(vector<int>& nums){\n        unordered_map<int, int> freq;;\n        int maxFreq = 0; \n        int maxElement = nums[0];\n\n        for (int num : nums){\n            freq[num]++;\n            if (freq[num] > maxFreq){\n                maxFreq = freq[num];\n                maxElement = num;\n            }\n        }\n\n        return (freq[maxElement] * 2 > nums.size()) ? maxElement : -1;;\n    }\n\npublic:\n    int minimumIndex(vector<int>& nums) {\n        \n        int dominant = getDominant(nums);\n        if (dominant == -1){ return -1; }\n        vector<int> dominantCount = precomputeDominantCount(nums, dominant);\n        int dominantEnd = dominantCount[nums.size()-1];\n\n        for (int i = 0; i < nums.size() - 1; i++) {\n            int leftCount = dominantCount[i];\n            int rightCount = dominantEnd - dominantCount[i];\n\n            if (leftCount * 2 > (i + 1) && rightCount * 2 > (nums.size() - i - 1)) {\n                return i;\n            }\n        }\n        \n        return -1;\n\n    }\n};\n```",
        "solution_url": "https://leetcode.com/problems/minimum-index-of-a-valid-split/6583957/c-precompute-dominantcount-subarray-by-j-sfyh",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "Array, Hash Table, C++",
        "hits": 5,
        "likes": 0,
        "dislikes": 0
    },
    {
        "event_id": 6553340,
        "event_type": "Solution",
        "problem_name": "Minimum Operations to Make Binary Array Elements Equal to One I",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/description/",
        "created_at": "2025-03-19T01:11:08.873779+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ / Python - Bit Manipulation ",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition here is to inspect each element and check whether it needs to be flipped, if it does then make the operation on the bit and the following 2 bits before checking whether the right subarray is able to be turned into 1. This is a divide and conquer approach.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nStore a variable `ans = 0` to hold the count of operations performed. Store variable `n = nums.size()` as the size of the input array. Now, utilise a for loop to iterate through all elements of nums. At each element inspect for condition `nums[i] == 0` to be true. If this is true then the bit must be flipped. Therefore, enumerate `ans++` and set the next two elements to their inverse digit using bit manipulation `nums[i+1] ^= 1`. Note that if this condition is found to be true for either of the last 2 elements in the array then return early -1 since this implies array cannot be turned into 1s. \n\nUpon completion of for loop. Simply return the count of operations stored in `ans` variable.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is size of input array nums\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(1)$$ Since constant number of varaibles used to hold count of ans.\n\n# Code\n```cpp []\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n        int ans = 0;\n        int n = nums.size();\n        for (int i=0; i<n; i++){\n            if (nums[i] == 0){\n                if (i > n - 3){ return -1; }\n                nums[i+1] ^= 1;\n                nums[i+2] ^= 1;\n                ans++;\n            }\n        }\n\n        return ans;\n    }\n};\n```\n``` python3 []\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans = 0\n        for i, num in enumerate(nums):\n            if (num == 0):\n                if i > len(nums) - 3:\n                    return -1\n\n                nums[i + 1] ^= 1\n                nums[i + 2] ^= 1\n                ans += 1\n        \n        return ans\n```",
        "solution_url": "https://leetcode.com/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/6553340/c-python-bit-manipulation-by-jo3-h-9ov1",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "Array, Bit Manipulation, C++, Python3",
        "hits": 2,
        "likes": 0,
        "dislikes": 0
    },
    {
        "event_id": 6549443,
        "event_type": "Solution",
        "problem_name": "Longest Nice Subarray",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/longest-nice-subarray/description/",
        "created_at": "2025-03-18T00:58:40.322796+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ / Python3 - Sliding Window",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is to use sliding window technique to search for subarrays which abide by the given condition. Iteratively expand the window by enumerating the right boundary of index and shrink the window until the condition in the description is satisfied. Update the answer variable to be max of current value and current window size. \n\n# Approach\n<!-- Describe your approach to solving the problem. -->\ninitialise three variables:\n1. `window = 0` to store the bitwise OR of all elements in current window\n2. `left = 0` to store the left index of the current window\n3. `ans = 0` to store the current largest valid window size\n\nNow, iterate values of `right` from 0 to nums.size() - 1 to investigate all potential right bounds of sliding window. For each incremental value of `right`, check whether the element `nums[right]` can be added to the window without breaking the conditions. This can be done by checking the  condition: `(window & nums[right]) != 0`. Since window holds a 1 in each position in which a bit is already present in the window, if the bitwise AND of this value and the candidate (nums[right]) that is attempting to be added is not zero then this implies that there is multiple 1s in one position. While this condition is true, reduce the window size by enumerating `left` and remove the leftmost element from the window by applying `window ^= nums[left]`.\n\nOnce the above has been done, the current window will be the largest possible given the current value of `right`. At this point we apply the OR operation to window to add `nums[right]` to the window; `window |= nums[right]`. Update the value of ans: `ans = max(ans, right - left + 1)`.\n\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O( n )$$ where n is the length of nums\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(1)$$\n\n# Code\n```cpp []\nclass Solution {\npublic:\n    int longestNiceSubarray(vector<int>& nums) {\n        int window = 0;\n        int left = 0;\n        int ans = 0;\n        for (int right=0; right<nums.size(); right++){ // iterate potential values for right boundary of window\n\n            while ((window & nums[right]) != 0){ // check whether right element can be added without contradiction\n                window ^= nums[left];\n                left++;\n            }\n\n            window |= nums[right]; // add nums[right] to window\n            ans = max(ans, right - left + 1); // update max window size\n\n        }\n\n        return ans;\n\n    }\n};\n```\n``` python3 []\nclass Solution:\n    def longestNiceSubarray(self, nums: List[int]) -> int:\n        window = 0\n        left = 0\n        ans = 0\n\n        for right in range(0, len(nums)):\n\n            while (window & nums[right]) != 0:\n                window ^= nums[left]\n                left += 1\n\n            window |= nums[right]\n            ans = max(ans, right - left + 1)\n\n        return ans\n```",
        "solution_url": "https://leetcode.com/problems/longest-nice-subarray/6549443/c-python3-sliding-window-by-jo3-h-jv1g",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "Bit Manipulation, Sliding Window, C++, Python3",
        "hits": 9,
        "likes": 0,
        "dislikes": 0
    },
    {
        "event_id": 6544797,
        "event_type": "Solution",
        "problem_name": "Divide Array Into Equal Pairs",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/divide-array-into-equal-pairs/description/",
        "created_at": "2025-03-17T00:22:14.687033+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ / Python - Frequency Map",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is to recognise that the actual pairs of elements do not have to be returned. Simply a boolean return type indicating whether this is possible. As such, we can use a frequency map to determine whether there is an even number of each unique number in nums. \n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nInitialise `unordered_map<int, int> freq_map` to store the frequency of each element. Iterate through `nums` and enumerate each value `freq_map[num]++ for num in nums`. Once this frequency map is build, iterate through items in map and check value for condition `value % 2 == 1`. If this value is true at any point, return false since this implies that there is a number that will not have a matching element to make a pair. Once all key - value pairs are checked for contradicion, if none has been found, return true.\n\nNote that key is not used in checking for contradiction since the actual value is not important, only its frequency.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ where n is number of elements in nums\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n$$O(n)$$ since average case will be n/2 unique numbers\n\n# Code\n``` cpp []\nclass Solution {\npublic:\n    bool divideArray(vector<int>& nums) {\n\n        // Initialse frequency map\n        unordered_map<int, int> freq_map;\n\n        // Count each occurrance of element in nums\n        for (int& n : nums){\n            freq_map[n]++;\n        }\n\n        // check for odd number of any element (proof by contradiction)\n        for (auto& [_, value] : freq_map){\n            if (value % 2 == 1){ return false; }\n        }\n\n        // else return true\n        return true;\n    }\n};\n```\n```python3 []\nclass Solution:\n    def divideArray(self, nums: List[int]) -> bool:\n        \n        # initialise frequency map\n        freq_map = {}\n\n        # count occurrances of elements\n        for num in nums:\n            if num not in freq_map:\n                freq_map[num] = 0\n            freq_map[num] += 1\n        \n        # check for odd count of element\n        for _, value in freq_map.items():\n            if value % 2 == 1:\n                return False\n        \n        # else return true\n        return True\n```\n",
        "solution_url": "https://leetcode.com/problems/divide-array-into-equal-pairs/6544797/c-python-frequency-map-by-jo3-h-4qrr",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "Array, Hash Table, Counting, C++, Python3",
        "hits": 1,
        "likes": 0,
        "dislikes": 0
    },
    {
        "event_id": 6541070,
        "event_type": "Solution",
        "problem_name": "Minimum Time to Repair Cars",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/minimum-time-to-repair-cars/description/",
        "created_at": "2025-03-16T02:07:50.478683+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ / Python - Binary Search",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nInituition is to search for a time that would be able to successfully repair all the cars while also being a minimum. First thought would be to use priority queues to determine time next car can be worked on and finished, this would be optimal if the time a mechanic take to copmlete a car is exponentially related to the number of cars he services. Because of this, we must use Binary Search.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nDefine two boundary values inbetween which much lie the optimal time. Set `left = 0` since the best case scenario is that there are zero cars to repair and it will take zero time to complete. Set `right = max(ranks * cars * cars)` since in the worst case scenario the worst mechanic will work on all of the cars, this is the upper bound for time. Note that this is assuming that mechanics can begin working on the next car in zero time. \n\nNow, definie the middle of the upper and lower bounds for our solution as `candidateTime = left + (right - left) / 2`. This serves as the midpoint and our candidate value for time. Check whether this candidate time is valid by passing to a member method. If this value is valid then set `ans = candidateTime` and move the upper bound to search for smaller candidate times `right = candidateTime - 1`. Otherwise, if the candidate time value is not valid, move the lower bound to search for larger candidate times `left = candidateTime + 1`. Repeat this until the search has set the upper and lower bounds such that `left > right`. \n\nTo check whether a given candidate time is valid, simply iterate through ranks and calculate the max number of cars a given mechanic can repair given the time. This can be calculated by using algebraic  principles on the formula for time. i.e. given candidateTime: `carsRepaired = floor(square_root(candidateTime / rank_of_mechanic))`. Keep a sum total of the number of `carsRepaired` and if the condition `carsRepaird >= cars` return True, else return False.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO(n log m) where n is ranks.size() and m is max(ranks) * cars * cars\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(1) due to constant number of variables used throughout search and validation.\n\n# Code\n``` cpp []\nclass Solution {\nprivate:\n    bool validTime(vector<int>& ranks, long long candidateTime, int cars){\n\n        long long carsRepaired = 0;\n        for (int rank : ranks){\n            carsRepaired += static_cast<long long>(sqrt(candidateTime / rank));\n            if (carsRepaired >= cars){ return true; }\n        }\n\n        return (carsRepaired >= cars);\n    }\n\npublic:\n    long long repairCars(vector<int>& ranks, int cars) {\n        long long left = 0;\n        long long right = static_cast<long long>(ranks.back()) * cars * cars;\n        long long ans = 0;\n        while (left <= right){\n            long long candidateTime = left + (right - left) / 2;\n            if (validTime(ranks, candidateTime, cars)){\n                right = candidateTime - 1;\n                ans = candidateTime;\n            } else {\n                left = candidateTime + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n```\n```python3 []\nclass Solution:\n    def validTime(self, ranks: List[int], candidateTime: int, cars: int) -> bool:\n        carsRepaired = 0\n        for rank in ranks:\n            carsRepaired += math.floor(math.sqrt(candidateTime/rank))\n            if carsRepaired >= cars:\n                return True\n        \n        return carsRepaired >= cars\n\n    def repairCars(self, ranks: List[int], cars: int) -> int:\n        left = 0\n        right = max(ranks) * cars * cars\n        ans = 0\n        while (left <= right):\n            candidateTime = left + (right - left) // 2\n            if (self.validTime(ranks, candidateTime, cars)):\n                ans = candidateTime\n                right = candidateTime - 1\n            else:\n                left = candidateTime + 1\n        \n        return ans\n```",
        "solution_url": "https://leetcode.com/problems/minimum-time-to-repair-cars/6541070/c-python-binary-search-by-jo3-h-hzk9",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "C++, Python3",
        "hits": 6,
        "likes": 0,
        "dislikes": 0
    },
    {
        "event_id": 6537488,
        "event_type": "Solution",
        "problem_name": "House Robber IV",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/house-robber-iv/description/",
        "created_at": "2025-03-15T01:11:03.489894+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ / Python - Binary Search",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nInituition is to select candidate values of capability and check for validity. Depending on whether this capability is valid with the provided valud of `k`, move the binary search to a new value.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nInitialise two variables `minElement = 1` and `maxElement = max(nums[i] for i in nums)` as the upper and lower potential value for answer.\n\nCalculate the midpoint of these two boundary values as `midElement = minElement + (maxElement - minElement) / 2`. Use this value to check whether it satisfies the conditions of the problem. If it does then set `ans = midElement` and change bounds to search for a smaller value by setting `minElement = midElement - 1`. Otherwise, search larger elements by setting `maxElement = midElement + 1`.  Continue until `maxElement > minElement`. At this point we will have the best candidate result stored in `ans`.\n\nTo work out the validity of a candidate, define function `validK()` which iterates through values in `nums` and dynamically calculates the number of houses that can be robbed at this candidate value. Return the bool returned when comparing the found values to k. If equal or larger than k, return `True` otherwise, return `False`.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO(n log n) where n is the size of input array nums; \n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(1) since constant number of variables are used.\n\n# Code\n```cpp []\nclass Solution {\nprivate:\n    bool validK(vector<int>& nums, int candidate, int k){\n        int i=0;\n        int ans=0;\n        while (i<nums.size()){\n            if (nums[i]<=candidate){\n                ans++;\n                i += 2;\n            } else {\n                i++;\n            }\n        }\n        return (ans >= k);\n    }\n\npublic:\n    int minCapability(vector<int>& nums, int k) {\n        if (k == 0){return 0;}\n        int maxElement = *max_element(nums.begin(), nums.end());\n        int minElement = 1;\n        int ans = -1;\n        \n        while (minElement <= maxElement){\n            int midElement = minElement + (maxElement - minElement) / 2;\n            if (validK(nums, midElement, k)){\n                maxElement = midElement - 1;\n                ans = midElement;\n            } else {\n                minElement = midElement + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n```\n``` python3 []\nclass Solution:\n    def validK(self, nums, candidate, k):\n        i = 0\n        ans = 0\n        while i < len(nums):\n            if (nums[i] <= candidate):\n                ans += 1\n                i += 2\n            else:\n                i += 1\n        return ans >= k\n\n    def minCapability(self, nums: List[int], k: int) -> int:\n\n        if k == 0:\n            return 0\n\n        maxElement = max(nums)\n        minElement = min(nums)\n        ans = -1\n\n        while minElement <= maxElement:\n            midElement = (minElement + maxElement) // 2\n            if (self.validK(nums, midElement, k)):\n                ans = midElement\n                maxElement = midElement - 1\n\n            else:\n                minElement = midElement + 1\n\n        return ans\n```",
        "solution_url": "https://leetcode.com/problems/house-robber-iv/6537488/c-python-binary-search-by-jo3-h-93oa",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "C++",
        "hits": 3,
        "likes": 0,
        "dislikes": 0
    },
    {
        "event_id": 6534161,
        "event_type": "Solution",
        "problem_name": "Maximum Candies Allocated to K Children",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/",
        "created_at": "2025-03-14T01:08:10.011174+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ / Python - Binary Search",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nThe maximum value of candies that can be assigned to any child is the size of the largest pile since each child can only be assigned one pile. The smallest value is the default case of 0 if there is more children than candies. Knowing this range of return values, binary search method can be used to identify which is the largest valid value for candies per child.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nDefine variable `ans` to hold the largest valid value for candies per child seen thus far. Initialise this variable `ans = 0` since if no valid values are found, zero will be returned. \n\nInitialise `left = 1` to hold the left boundary of the search values (can ignore 0 since initialised ans to zero), and `right = max(candies)` as the max value ans could take. Binary search by initialising `int candidate = left + (right - left) / 2`, this is effectively the mid-point between the search bounds left / right. Check this candidate value for ability to distribute to `k` children (see below for method). If this value is valid then update `ans = candidate` and move the left bound to check larger, unchecked, values `left = candidate + 1`. If the candidate value is invalid then move right bound to check smaller candidate values for validity `right = candidate - 1`. Repeat this process while `left <= right`. Once this loop is completed, best found result is stored in `ans` and can be returned.\n\nTo calculate whether a candidate value `candidate` is valid, abstract to a function `validCandies()`. This function counts the potential children that can be assigned this number of candies. Initialise a variable `childrenCount` to count the children that can receive this number of candies. Iterate each pile `candies[i]` and add to the count the max number of sub-piles of size `candidates` that can be made from this pile: `childrenCount += candies[i] / candidates`. Return true if `childrenCount >= k` indicating a valid candidate value.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO(m * log n) where n is `max(candies[i])` and m is size of `candies`\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(n) where n is the size of the input array `candides`\n\n\n# Code\n```cpp []\nclass Solution {\nprivate:\n    bool validCandies(int candidate, vector<int>& candies, long long k){\n        long long countChildren = 0;\n        for (auto& pile : candies){\n            countChildren += pile / candidate;\n            if (countChildren >= k) return true;\n        }\n        return (countChildren >= k);\n    }\n\npublic:\n    int maximumCandies(vector<int>& candies, long long k) {\n\n        // initialise variables\n        int ans = 0;\n        int left = 1;\n        int right = *max_element(candies.begin(), candies.end());\n\n        // binary search values for valid candies per child (ans), store the most recently found\n        while (left <= right){\n            int candidate = left + (right - left)/2;\n            if (validCandies(candidate, candies, k)){\n                ans = candidate;\n                left = candidate + 1;\n            } else {\n                right = candidate - 1;\n            }\n        }\n\n        return ans;\n    }\n};\n```\n``` python3 []\nclass Solution:\n    def validCandies(self, candidate: int, candies: List[int], k: int):\n        childrenCount = 0\n        for pile in candies:\n            childrenCount += pile // candidate\n            if childrenCount >= k:\n                return True\n\n        return childrenCount >= k\n\n    def maximumCandies(self, candies: List[int], k: int) -> int:\n        ans = 0\n        left = 1\n        right = max(candies)\n        while left <= right:\n            candidate = left + ((right - left) // 2)\n            if (self.validCandies(candidate, candies, k)):\n                ans = candidate\n                left = candidate + 1\n            else:\n                right = candidate - 1\n\n        return ans\n```",
        "solution_url": "https://leetcode.com/problems/maximum-candies-allocated-to-k-children/6534161/c-python-binary-search-by-jo3-h-wg4d",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "C++, Python3",
        "hits": 3,
        "likes": 0,
        "dislikes": 0
    },
    {
        "event_id": 6531899,
        "event_type": "Solution",
        "problem_name": "First Bad Version",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/first-bad-version/description/",
        "created_at": "2025-03-13T08:43:48.850464+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ / Python - Binary Search",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition here is exactly the same as a binary search for a number that is in an array, however, in this case the condition we are looking for is not an equality of number at some index to a target number, the condition is a true result from the `isBadVersion()` API.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nset a variable `left` to 1 (the minimum version number) and `right` to the input to the function `n`. Also initialise an int `ans` which will store the best answer to the current iteration of the loop. While left is less than or equal to right we can find the midpoint number `mid` and check whether this version is bad. If version is bad then update `ans = mid` and move `right = mid - 1`, if the version is good then move `left = mid + 1`. Once the loop is exited, then the smallest version number which is bad will be stored in `ans`. Return this value.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO(log n) where n is the input to the `firstBadVersion()` function\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(1) since only three ints are required to find solution\n\n# Code\n```cpp []\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int right) {\n        int left = 1;\n        int ans;\n        while (left <= right){\n            long long mid = left + (right - left)/2;\n            if (!isBadVersion(mid)){\n                left = mid + 1;\n            } else {\n                ans = mid;\n                right = mid - 1;\n            }\n        }\n        return ans;\n    }\n};\n```\n```python3 []\n# The isBadVersion API is already defined for you.\n# def isBadVersion(version: int) -> bool:\n\nclass Solution:\n    def firstBadVersion(self, right: int) -> int:\n        left = 1\n        ans = 0\n        while (left <= right):\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return ans\n```",
        "solution_url": "https://leetcode.com/problems/first-bad-version/6531899/c-python-binary-search-by-jo3-h-wnsf",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "C++",
        "hits": 1,
        "likes": 0,
        "dislikes": 0
    },
    {
        "event_id": 6531830,
        "event_type": "Solution",
        "problem_name": "Merge Two Binary Trees",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/merge-two-binary-trees/description/",
        "created_at": "2025-03-13T08:05:25.450193+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ / Python - Recursion ",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIdea is to traverse both trees at the same time and handle merging at a single node before recursively merging the children nodes. \n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nBegin with the root nodes as in the `mergeTrees()` function. Check whether both nodes are not `NULL`. If either nodes is `NULL` then there will be zero future nodes down this branch that need merging since only one of the trees is defined. As a result, return the defined node. If both nodes are defined then add the value of `root2->val` to `root1->val`, this effectively merges the nodes. Now, recurively set the children of `root1` by recursively calling the function. Return `root1`.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO(n) where n is the number of nodes in the larger tree \n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(1) since the function merges the trees inplace.\n\n# Code\n```python3 []\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n\n        # if root1 is undefined return root2\n        if not root1:\n            return root2\n\n        # if root2 is undefined return root1\n        if not root2:\n            return root1\n\n        # merge root2 into root1 then return root1\n        root1.val = root1.val + root2.val\n        root1.left = self.mergeTrees(root1.left, root2.left)\n        root1.right = self.mergeTrees(root1.right, root2.right)\n\n        return root1\n```\n```cpp []\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n\n        // if either node is undefined return the other\n        if (!root1){ return root2; }\n        if (!root2){ return root1; }\n        \n        // if both nodes defined then add root2->val to root1 and merge children\n        TreeNode* ans = new TreeNode();\n        root1->val = root1->val + root2->val;\n        root1->left = mergeTrees(root1->left, root2->left);\n        root1->right = mergeTrees(root1->right, root2->right);\n        \n        return root1;\n    }\n};\n\n```",
        "solution_url": "https://leetcode.com/problems/merge-two-binary-trees/6531830/c-python-recursion-by-jo3-h-nn7a",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "Python3",
        "hits": 2,
        "likes": 0,
        "dislikes": 0
    },
    {
        "event_id": 6530873,
        "event_type": "Solution",
        "problem_name": "Zero Array Transformation II",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/zero-array-transformation-ii/description/",
        "created_at": "2025-03-13T01:48:29.898324+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ Solution - Binary Search",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nInitial intuition to find this smallest value `k` would be to set value of `k` to zero and iteratively increase until a valid zero array is formed from processing the first `k` queries. Unfortunately this is far too slow for the requirements.\n\nA more efficient idea would be to binary search values of `k` until the smallest valid value is found. This reduces the complexity of the search to O(log n). \n\nNow we can simply define a function to check whether the current value of `k` will result in a valid Zero Array. Note that this function can be optimized independently.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nThe approach is to take the `minZeroArray()` function and create a binary search for `k`. In doing this, we can set an `int ans` variable whick holds the best answer found so far. On each loop of the binary search, if the midpoint value for `k` creates a valid Zero Array then we can update `ans` and continue moving the binary search bound `left` and `right`.\n\nOnce the bounds `left` and `right` are equal, we can exit the binary search and conclude that `ans` holds the best answer we have found. \n\nThe `isValidZeroArray()` function takes parameter `int k` which is the current value of the binary search. To check for a valid Zero Array we can take each query and decrement the left index of a difference array and increment the right index if its within bounds. After processing each query we check for valid conditions by calculating the cumulative decrement at each position and checking that the total is sufficient to reduce nums[i] to zero. \n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO((m+n) * log (n))\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(n + m)\n\n# Code\n```cpp []\nclass Solution {\nprivate:\n    vector<int> nums;\n    vector<vector<int>> queries;\n    int n;\n\n    bool isValidZeroArray(int k){\n        \n        vector<int> diff(n, 0);\n        for (int i=0; i<k; i++){ // iterate first k queries\n\n            int l = queries[i][0];\n            int r = queries[i][1];\n            int val = queries[i][2];\n            diff[l] -= val;\n            if (r+1 < n){\n                diff[r+1] += val;\n            }\n\n        }\n\n        // check for zero array\n        int total = 0;\n        for (int i=0; i<n; i++){\n            total += diff[i];\n            if (nums[i] + total > 0){ return false; }\n        }\n\n        return true;\n    }\n\npublic:\n    int minZeroArray(vector<int>& _nums, vector<vector<int>>& _queries) {\n\n        // set member variables for access\n        nums = _nums;\n        queries = _queries;\n        n = nums.size();\n\n        // check for array already zero\n        if (isValidZeroArray(0)) {return 0;}\n        \n        // binary search values of 'k' until smallest valid value is found\n        int left = 0;\n        int right = queries.size();\n        int ans = -1;\n        while (left <= right){\n            int k = (left + right) / 2;\n            if (isValidZeroArray(k)){\n                ans = k;\n                right = k - 1;\n            } else {\n                left = k + 1;\n            }\n        }\n\n        return ans;\n    }\n};\n```",
        "solution_url": "https://leetcode.com/problems/zero-array-transformation-ii/6530873/c-solution-binary-search-by-jo3-h-qhpy",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "C++",
        "hits": 11,
        "likes": 0,
        "dislikes": 0
    },
    {
        "event_id": 6526045,
        "event_type": "Solution",
        "problem_name": "Maximum Count of Positive Integer and Negative Integer",
        "problem_description": null,
        "problem_url": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/description/",
        "created_at": "2025-03-12T00:41:17.212839+00:00",
        "status": "Submitted",
        "difficulty": "",
        "solution_name": "C++ solution; O(n) one pass.",
        "solution_content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is to maintain a count of each num in nums that is smaller than zero and larger than zero. Once we have these two numbers we can simply return the larger of the two. \n\nA more efficient method, since the input vector nums is sorted in non_decreasing order, would be to binary search for number 0. Once zero has been found we can use a pointer to find the index of the first number which is above zero and the last number smaller than zero. Using each of these indexes we can simply calculate the elements to the right/left of the position and return the larger of the two. \n\n# Approach\n<!-- Describe your approach to solving the probem. -->\nInitialise two integers to store the count of negative and positive numbers inspected. Iterate through each num in nums and check conditions that num is larger than or smaller than zero. Enumerate counts accordingly.\nReturn the max of the two values.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO(n) Time complexity. Where n is length of input arry nums.\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nO(1) Space complexity. All cases only use 2 int datatypes to compute.\n\n# Code\n```cpp []\nclass Solution {\npublic:\n    int maximumCount(vector<int>& nums) {\n        int pos = 0;\n        int neg = 0;\n        for (auto n : nums){\n            if (n>0){pos++;}\n            else if (n<0){neg++;}\n        }\n        return max(pos, neg);\n    }\n};\n```",
        "solution_url": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/6526045/c-solution-on-one-pass-by-jo3-h-iidi",
        "total_accepted": null,
        "total_submissions": null,
        "total_accepted_ratio": null,
        "topics": "C++",
        "hits": 1,
        "likes": 0,
        "dislikes": 0
    }
]